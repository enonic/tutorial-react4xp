= Starter: Build React sites in XP
:toc: right
:imagesdir: media/

image::react4xp.svg["React4xp logo" width=256px]

This tutorial will show you how to build XP sites and apps with React rendering.

[NOTE]
====
This is _not_ a tutorial for learning React in itself, or how to get started using Enonic XP. For that, many excellent guides exist already, see for example https://reactjs.org/tutorial/tutorial.html[the official intro to React] or https://developer.enonic.com/start[the Enonic XP developer portal].

Being a little familiar with https://webpack.js.org/guides/getting-started/[webpack] doesn't hurt either.
====

{nbsp} +

== Introduction

This tutorial takes you through the basic steps of creating a React app, helping you kickstart a React4xp project of your own.

During this exercise you will:

- set up the starter and meet the React4xp library,
- learn how to use it to render a basic React component from any regular XP controller - in this case a part,
- inject editorial data into your React component,
- see how to point the controller to the React components - and where to put them in your project source,
- dig a little deeper into ways of controlling the rendering,

[NOTE]
====
The starter and this guide aims for how-to, what-is and setup of React4xp with *XP 7*. An XP6-compatible version will be released shortly. If you're using XP6 and the XP6 starter, only the React4xp installation and build commands are different from XP7. The rest of the way it's pretty identical, so *you can still use this guide for both versions.*
====

{nbsp} +
{nbsp} +

=== The React4xp library

React4xp is an XP library that:

- makes it easy to get started with rendering React from ordinary XP controllers - making JSX look like any other templating engine,
- is flexible enough to cover many more advanced use cases,
- features some tricks right out of the box to conveniently cover a couple of common needs - such as isomorphic client- or serverside rendering and hydration, build flow and compilation, automated asset serving with optimization, and more
- aims to be modular and tweakable, making it possible to pop the hood, pick it apart and set things up your own way. Godspeed!

https://github.com/enonic/lib-react4xp/blob/master/README.md#installing-the-library[The React4XP documentation is right here].

{nbsp} +
{nbsp} +
{nbsp} +

== Get started

=== Create a starter project

To setup a project locally, run the following command:

  enonic project create -r starter-react4xp

Remember to create a *new XP sandbox* when completing the project wizard.

NOTE: *Don't have the Enonic CLI?* Visit the https://developer.enonic.com/start[Getting started guide] to install it.

{nbsp} +

=== Build and Deploy

To build and deploy the app, run this command from your shell:

  enonic project deploy

Accept starting the sandbox.

[NOTE]
====
To verify that your app started successfully, you should find an entry similar to this in the sandbox log:

  2019-04-09 13:40:40,765 INFO ... Application [<name.of.your.app>] installed successfully
====


{nbsp} +
{nbsp} +
{nbsp} +

== Project structure

If you're used to working with an https://developer.enonic.com/guides/my-first-webapp[ordinary] XP project with https://developer.enonic.com/templates/webpack[webpack], the structure will look familiar - the biggest news is the folder `react4xp/` under `resources/`.

TIP: You don't need to know the following structure by heart to get started. *Just put your JSX source files under `react4xp/_entries/` or under `site/`, and you're ready to build and run.*

Your project folder should look something like this:

.Selected files:
[source,files]
----
build.gradle <--1-->
settings.gradle <--1-->
package.json <--2-->
build/ <--3-->
src/
  main/
    resources/
      assets/ <!--4-->
      react4xp/ <!--5-->
        _entries/ <!--6-->
          REPLACE_ME.jsx <!--7-->
      site/
        parts/ <!--8-->
        pages/ <!--8-->
        REPLACE_ME.jsx <!--7-->
      webapp/ <!--9-->
----

<1> The gradle files are used by the build system. The starter includes some setup here: the *lib-react4xp* library and some building tasks,
<2> `package.json` sets up NPM import of some packages that React4XP and the build process need,
<3> `build/` will contain output files from the build process. The files from the React4XP part of the build will all be put into the subfolder `build/resources/main/assets/react4xp`. These are used after the build, by both client- and server-side runtime processes,
<4> ..just note that your React4XP source files should normally NOT be put in `assets/react4xp`! The `assets/` folder is just used in the regular XP way for other, general assets: non-React4xp JS, CSS, icons, etc.
<5> *React4XP will instead look for your JS and JSX files under the `react4xp/` folder* (they are kept apart from other XP source files because they are treated differently in the build). You can make subfolders under here, they will be compiled into "sub-libraries" - reusable _chunks_ that contain code that your ReactXP entries can import (but are not themselves accessable by React4XP). More on this below.
<6> The *one special magic folder* that will not be turned into chunks, is `react4xp/\_entries/`. This is here you put your *entries* - the React component source files that can be accessed by React4xp in the XP controllers. We'll get back to this below.
<7> Two `REPLACE_ME.jsx` files: placeholders for webpack. Remove each of these when you've added one or more React source file below `react4xp/_entries/` and `site/`.
<8> Below the `site/parts/` and `site/pages/` subfolders is as always where you put your XP parts and pages. Now with React4xp, *you can also put JSX entries together with your parts and pages*. This is the easiest way to use a React4XP entry from a part/page controller.
<9> Outside of the scope of this tutorial but worth mentioning: the `webapp/` folder containing the root webapp controller. React4XP supplies services that allow static HTML pages to refer to and request compiled entries.


{nbsp} +
{nbsp} +
{nbsp} +

== Examples

These examples are incremental: the later, advanced examples are clearer if you've seen the previous ones.

TIP: They can be downloaded along with everything needed to run, by checking out the https://github.com/enonic/starter-react4xp/tree/examples[examples branch of starter-react4xp]

{nbsp} +

=== 1: Hello World

Let's make a simple XP part that contains a react component: `01-minimal-example`

.Files involved:
[source,files]
----
site/parts/01-minimal-example/
  01-minimal-example.xml
  01-minimal-example.jsx
  01-minimal-example.es6
----

Add a *part definition*. It doen't need anything special, just boilerplate:

.01-minimal-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>01 - Minimal Example</display-name>
  <description>Simple client-side example</description>
  <form />
</part>
----

*Now for the React component itself - the entry:*

.01-minimal-example.jsx
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) => <p>Hello {props.greetee}!</p>;
----

[NOTE]
====
_Entries in React4XP are the React components that can be accessed by React4XP_. They are just any standard JSX file, as long as it:

- default-exports a function that returns a React element, and
- is placed under the folder `/react4xp/_entries` or like in this example: in a part or page folder under `site/`.
====

The returned function can take an optional `props` object parameter. Our entry will receive a `greetee` prop and greet it with a magnificent _Hello_.


Now moving on, make the *part controller* that uses React4XP to render the entry:

.01-minimal-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const component = portal.getComponent();
    const props = { greetee: "world" };

    return React4xp.render(component, props, request);
};
----

It basically just imports `React4xp` and uses the `.render` function, similar to how you might be familiar with from Thymeleaf or other XP template engines:

- The first argument is a reference to the template (just like the first view reference in the Thymeleaf renderer). In our case the template is the React4XP entry, and React4XP uses the `component` data (for the part itself) to locate the JSX file in the part's own folder (expecting the same file name as the part).
- The second argument, `props`, is similar to the `model` argument in the Thymeleaf renderer. No big surprise: it's passed to the entry's `props`. Here is the _world_ we're about to greet.
- The third `request` argument is necessary for a fully activated React rendering. You _can_ leave it out to render the entry as pure HTML if you like JSX as a pure templating language, but it won't be activated (https://reactjs.org/docs/react-dom.html#hydrate[hydrated]) in the browser.

*The returned response object* from `.render` is sent straight from the controller to the client, and contains:

- a `body` field with a server-side rendering (in static HTML) of the entry with the entered props,
- and some `pageContributions` that make the client activate the React entry (containing the necessary asset links and React hydration commands).

[NOTE]
====
An important difference from Thymeleaf's renderer is that `React4XP.render` generates _a full response object_ that can be directly returned from the controller, instead of just HTML that you need to wrap in a `body` field in the controller's response object.
====

{nbsp} +
{nbsp} +

*That's it. Now let's add this part to a page in Content Studio and render it:*

- Run `enonic project deploy` from your shell, start the sandbox and direct your browser to `localhost:8080/admin`.
- Log in to XP and open Content Studio.
- Create some content with a Region (e.g. the starter includes a Default Page controller that you can use to diplay e.g. https://market.enonic.com/vendors/enonic/landingpage-lib[a landing page] or even just a site).
- Insert a new part into the region, and select the `01-minimal-example` part you just made.
- Enter the preview to view the content outside of Content Studio. You should now see:

[.thumb]
image::hello-world.png["Glorious greeting of the very existence itself!" width=492px]

{nbsp} +
{nbsp} +

Curious about what happened here? *View the page source code in the browser* to see what `.render` created - something like this (the number-tagged lines):
[source,html,options="nowrap"]
----
<!DOCTYPE html>
<html>
  <head>(...)</head>

  <body>

    <main data-portal-region="main" class="xp-region">
      <div (...) id="parts_01-minimal-example__main_0">
      	<p data-reactroot="">Hello <!-- -->world<!-- -->!</p> <!--1-->
      </div>
    </main>

    <script src="(...) /react4xp/externals.88e80cab5.js"></script>  <!--2-->
    <script src="(...) /react4xp-client/"></script> <!--3-->
    <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--4-->
    <script defer> <!--5-->
      React4xp.CLIENT.hydrate(
        React4xp['site/parts/01-minimal-example/01-minimal-example'],
        "parts_01-minimal-example__main_0",
        { "greetee": "world", "react4xpId": "parts_01-minimal-example__main_0" }
      );
    </script>

   </body>
</html>
----

<1> A container element with an ID, and inside it: an HTML representation of the JSX entry, pre-rendered by React4XP on the server with the initial props.
<2> A standard `externals` chunk (the exact path may vary with local setups, so it's truncated to `(...)`. The same goes for the cache-busting hash in the filename). This contains React and ReactDOM, built-in with React4XP.
<3> The React4xp client wrapper, which enables the hydration command in point #5, among other things. A global client-side object is created, `React4xp`, which will contain all things React4xp in runtime. The client wrapper is `React4xp.CLIENT`.
<4> The entry itself - the compiled version of `01-minimal-example.jsx`.
<5> Calling `React4xp.CLIENT.hydrate`, the hydration of the entry along with a path pointer to the entry (we'll get back to this below, as the concept of _jsxPath_), the ID of the container element the entry is rendered into, and the props.

[NOTE]
====
We only added the `greetee` prop. The other one, `React4xpId`, is the unique ID of the component, same as the container element ID. It's always added as a react prop for each entry, conveniently helping to separate multiple instances of the same component (e.g. allowing them to share a common redux store without meddling with each other's state).
====
{nbsp} +
{nbsp} +

=== 2: Serverside rendering

In this example we'll create a new part, similar to the link:#_1_hello_world[first] one but with these differences:

- Server-side rendering with hydration: `.render` instead of `.renderSafe`. They have the same parameter signature, but we'll also use it slightly differently here with some manual options:
- A thymeleaf HTML view already exists, and we're rendering the react component into a target container element in it,
- We're not using a 'local' JSX component inside the part. Instead, we're using the `jsxPath` to point elsewhere; to reuse the react entry from the first example.
- We're setting the ID manually, instead of letting `.render` generate it.
- Since we're manually setting both the ID and the jsxPath pointer, we don't need the `component` parameter.
- However, we'll inject some editorial data into the react commponent, using the props. We'll use `getComponents` to fetch those.

.Files involved:
[source,files]
----
site/parts/
  01-minimal-example/
    01-minimal-example.jsx
  02-serverside-example/
    02-serverside-example.xml
    02-serverside-example.html
    02-serverside-example.es6
----

Still an unremarkable *part definition*, but now there's a `greetee` TextLine input field. Here we'll enter something editorial in Content Studio, fetch it in the controller and inject it into the react component.

.02-serverside-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>02 - Server-Side Example</display-name>
  <description>Server-side rendered react component</description>
  <form>
    <input name="greetee" type="TextLine">
      <label>What should be our greeting (after 'Hello')?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>world</default>
    </input>
  </form>
</part>
----

*The view* demonstrates how a target container can be anywhere in an HTML file, and still receive the react injection - same as in vanilla react - as long as we point to it with the ID: `serverside-example-container`.

NOTE: If `.render` or `.renderSafe` are given a `body` to inject react into, but there's no element in the HTML with an `id` that matches the `React4xpId` of the component, a new, empty container with a matching `id` will be added inside the `body`, at the end. In this case it would be injected between line 5 and 6:

.02-serverside-example.html
[source,html,linenums,options="nowrap"]
----
<div class="serverside-example">
    <h2>Server-side rendering example</h2>
    <p>Server-side rendered and hydrated, inserted below:</p>
    <div id="serverside-example-container"></div>
    <p>(SSR example is done).</p>
</div>
----

As usual, the important React4xp stuff happens in *the part controller*:

.02-serverside-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

// View file
const view = resolve('02-serverside-example.html');

exports.get = function(request) {
    // Fetching the component data we entered (or, we're about to)
    // in the textfield in Content Studio:
    const component = portal.getComponent();

    // The `.render` shorthand method produces a server-side rendering. <!--1-->
    return React4xp.render(
        request, // `request` is still used to determine viewing mode.
        {
            // Extracting `greetee` from the component data,
            // and setting the value as the `greetee` prop
            props: { greetee: component.config.greetee },

            // Uses jsxPath to use the react entry from the previous
            // example, `01-minimal-example.jsx`. <!--2-->
            jsxPath: 'site/parts/01-minimal-example/01-minimal-example',

            // Manually setting the component's `React4xpId`,
            // identical to the `id` of the rendering target container.
            id: 'serverside-example-container',

            // The `body` parameter is an HTML string.
            // Here, itâ€™s rendered by Thymeleaf based on the view file. <!--3-->
            body: thymeleaf.render(view, {})
        }
    );
};
----

Notes:

<1> In live view, `.render` also *hydrates* the rendered HTML - post-filling it with the active react and JS functionality on the client

<2> This *jsxPath structure* is common for all JSX entries below the `site/` folder: `site/<parts-or-pages>/<part-or-page-folder-name>/<filename>`.

<3> *Body and pageContributions parameters:* The `body` and `pageContributions` parameters are *pass-through*! Had this been the `.renderSafe` client-side rendering function, `body` would just have become the `body` in the response output, only with a container element added (possibly. Nothing's added if a matching-`id` element is found in it). But with `.render`, the react component is rendered to HTML by the server using the initial `props`, and inserted into the target container in `body` (which, again, might be a generated target container if the input HTML is missing one). This modified `body` is then returned. On the client, `.render` will `.hydrate` the container, filling in and activating the react component. The `pageContributions` parameter isn't shown here, but works the same way: appending the React4xp output pageContributions to the input ones, if any were given. See the next example.

{nbsp} +
{nbsp} +

*Okay, enough code - let's run the example!*

Add the new part `02-serverside-example` to our page in Content Studio (the way we did in link:#\_1_hello_world[the previous example]). When we edit the part and open the _inspect_ panel on the right, we see the TextField asking us _"What should be our greeting?"_ It suggests _"world"_, but for variation we'll enter _"from the server side"_. This is the `greetee` value, it gets prop'ed into the react component, and we can see the rendered result in the preview on the left:

[.thumb]
image::editing-serverside.png["" width=1037px]

The output page source from the server is very similar to the previous example:
[source,html,options="nowrap"]
----
<body>
  <main data-portal-region="main" class="xp-region">

    <div class="serverside-example">
      <h2>Server-side rendering example</h2>
      <p>Server-side rendered and hydrated, inserted below:</p>
      <div id="serverside-example-container">
        <p data-reactroot="">Hello <!-- -->from the server side<!-- -->!</p> <!--1-->
      </div>
      <p>(SSR example is done).</p>
    </div>

  </main>

  <script src="(...) /react4xp/externals.88e80cab5.js" ></script>
  <script src="(...) /react4xp-client/" ></script>
  <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--2-->
  <script defer> <!--3-->
    React4xp.CLIENT.hydrate(
      React4xp['site/parts/01-minimal-example/01-minimal-example'],
      "serverside-example-container" ,
      {"greetee":"from the server side","react4xpId":"serverside-example-container"}
    );
  </script>
</body>
----

Most noteworthy:

<1> The target container is not initially empty anymore, but contained rendered HTML from the server.
<2> The imported entry is still the same as in the previous example. This is the compiled version of the JSX component we pointed to with `jsxPath` in the controller.
<3> Instead of `.render`, we're triggering `.hydrate`. Here, that doesn't make a difference since our react component doesn't have any more active stuff in it than just outputting an HTML string. But had it had things like event listeners, state, connections to thirdparty libraries etc, `.hydrate` would have hooked those up to the DOM structure created in the target container element, creating a working, active component.

TIP: Server-side rendering can take a long time to produce an output on the first rendering (several seconds). This should happen _very rarely or never_ after the first rendering on the server. What happens is that the component is parsed, compiled and cached on the server. After that, repeated renderings even with different props are very fast!

{nbsp} +
{nbsp} +

=== 3: React4xp objects

Here we won't use the shorthand functions `.render` or `.renderSafe`. Instead, we'll use the explicit syntax that the shorthand functions use under the hood. We'll construct a data-holding React4xp object, and use its built-in methods to specifically and separately render the `body` and the `pageContributions`.

This provides more fine-grained control and opportunities for logic steps during the component creation.

Other new features demonstrated:

- The controller as the source of the target container ID, injecting it both into the view and the react component,
- Referring to a React component outside of XP's `/site/` structure, in the base directory `/react4xp/\_entries`,
- Rendering a `body` with Thymeleaf once, and using it as a static pre-rendered template.
- Making some raw XP pageContributions before rendering, with a script with inserted editorial data. Then passing that `pageContributions` object through the `.renderClientPageContributions`, and getting new pageContributions (which activate the react component as we did before) added to it - retaining the existing pageContributions.

.Files involved:
[source,files]
----
react4xp/_entries/
  ColorThing.jsx
site/parts:
  /03-customflow-example/
    03-customflow-example.xml
    03-customflow-example.html
    03-customflow-example.es6
----

As usual, we start with the *part definition*, and it's still the source of some editorial data: `color`.

.03-customflow-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>03 - CustomFlow Example</display-name>
  <description>AKA. The Color Thing</description>
  <form>
    <input name="color" type="TextLine">
      <label>What's the color of the thing?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>red</default>
    </input>
  </form>
</part>
----

Next, let's look at the *react component*. Still not very advanced, but at least it's colorful (sorry):

.ColorThing.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) =>
  <div style={{border: `1px dotted ${props.color}`,margin:"5px",padding:"5px" }}>
    <h2>The {props.color} thing</h2>
    <p style={{color: props.color}}>Hey, I'm pretty {props.color}!</p>
  </div>;
----

The thymeleaf *view* has no other purpose than to show that an ID is inserted, turning this into a target container:

.03-customflow-example.html
[source,html,linenums,options="nowrap"]
----
<div data-th-id="${targetId}"></div>
----

Finally, *the controller*:

.03-customflow-example.es6:
[source,javascript,linenums,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

// Sets the ID for both the react component and the target container...
const TARGET_ID = "color-greeter-id";

const view = resolve('03-customflow-example.html');
const model = {
    targetId: TARGET_ID
};
// ... which is rendered to a static HTML string here and only once:
const PRE_RENDERED_BODY_TEMPLATE = thymeleaf.render(view, model);

exports.get = function(request) {
    const component = portal.getComponent();

    // Constructor for a React4xp object, setting one mandatory parameter:
    // either an XP component object, or as in this case: a jsxPath string. <!--1-->
    const reactComp = new React4xp('ColorThing');

    // Builder pattern for setting the additional optional attributes. <!--2-->
    reactComp
        .setId(TARGET_ID)
        .setProps({
            color: component.config.color
        });

	// Making a normal XP pageContributions object <!--3-->
	const preExistingPageContributions = {
        bodyEnd: `<script>
            console.log('Okay, rendered the ${reactComp.props.color} thing.');
        </script>`
    };

    // Without the shorthand rendering, there are separate rendering
    // functions for body and pageContributions: <!--4-->
    return {
        // `.renderTargetContainer` renders ONLY the target container
        // - no server-side added react content. <!--5-->
        body: reactComp.renderTargetContainer(PRE_RENDERED_BODY_TEMPLATE),

        // `.renderClientPageContributions` only makes
        // client-side rendering script tags. <!--6-->
        pageContributions: reactComp.renderClientPageContributions(
            preExistingPageContributions
        )
    }
};
----

Footnotes from the comments:

<1> Why is `ColorThing`, and only that, the jsxPath to `ColorThing.jsx`? Because it's at the root level of the magic react4xp-entries base folder: `src/main/resources/react4xp/_entries`.

<2> The builder pattern means these optional methods can be chained like in the example or happen separately - in any sequence. The example lines here are equivalent to:

	reactComp.setProps({color: component.config.color});
	reactComp.setId(TARGET_ID);

<3> The `props` are already set in the React4xp `reactComp` object. We can fetch attributes from it before the rendering, in this case reading the `color` prop and injecting it into this mini-script.

<4> So there's no automatic selection of rendering mode. *Try to avoid active client-side JS running in Content Studio's edit mode*. Take care when rendering manually like this. The simplest way is to detect the viewing mode from the `request` object and skip the pageContributions.

<5> `.renderTargetContainer` can be used without an argument. It will then simply generate an empty target container for you, with an `id` matching the react components ID.

<6> We're passing `preExistingPageContributions` _through_ `.renderClientPageContributions`, keeping the script line we made and adding the component's necessary pageContributions to it when it's returned. This method can also be run without an argument, giving you fresh pageContributions.

{nbsp} +

*Okay, let's take a look:*
As before, open Enonic XP, make a new part, select the new part we made: 03-Customflow Example. Edit the part config, and change the color of the thing, for example to "blue". Save, and open the preview.

Unsurprisingly, we should get something like this:

[.thumb]
image::the-blue-thing.png["" width=1068px]

We also see in the console that the little `console.log` script from the controller has picked up the `color` prop _from_ the object, and passed through the `.renderClientPageContributions`, only joined by the generated JS that the client uses to render the blue thing. The rest of the output follows the same logic as we've seen before for a client-side rendering:

[source,html,options="nowrap"]
----
<body>
  <main data-portal-region="main" class="xp-region">
    <div id="color-greeter-id"></div>
  </main>

  <script src="(...) /react4xp/externals.88e80cab5.js"></script>
  <script src="(...) /react4xp-client/"></script>

  <script>console.log('Okay, rendered the blue thing.');</script>

  <script src="(...) /react4xp/ColorThing.js"></script>
  <script defer>
    React4xp.CLIENT.render(
      React4xp['ColorThing'],
      "color-greeter-id",
      { "color": "blue", "react4xpId": "color-greeter-id" }
    );
  </script>
</body>
----

{nbsp} +
{nbsp} +

=== 4: A part with multiple react components, chaining, nesting, hydration

A more complex example, where we'll look at using *multiple react components in a single part* - including reusing multiple instances of _the same_ react component and making them unique within the part:

- rendering a stateful component, more powerful than before,
- ...which is serverside-rendered as a passive string and then activated in the client with `.hydrate`,
- chaining (passing the body and pageContributions through multiple react4xp data objects),
- nesting shared, non-entry react components in an entry,
- how `import`-ing non-entry code results in a predictable chunk structure,

.Files involved:
[source,files]
----
react4xp/
  myChunk/
    BuilderClicker.jsx <!--1-->
  _entries/
    mySubfolder/
      BuilderClickerEntry.jsx <!--2-->
site/parts:
  /04-chaining-example/
    04-chaining-example.jsx <!--3-->
    04-chaining-example.xml <!--4-->
    04-chaining-example.html <!--5-->
    04-chaining-example.es6 <!--6-->
----

{nbsp} +
*1.* `BuilderClicker` is a shared react component that will be imported by `BuilderClickerEntry` and put inside the chunk `myChunk.<hash>.js` - because it's below the `myChunk` subfolder instead of `_entries`. *As a non-entry, it will not get a jsxPath*, so it will be better optimized but must be imported by an entry to be used in React4xp. It's also a *stateful and active* react component: the props are stored and output after one another in a `<h3>` element, and can be changed: each of them are repeated/doubled when clicked in the client (so repeated clicks will build a lot of text, hence the name):

.BuilderClicker.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

class BuilderClicker extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            first: props.first,
            second: props.second,
        }
    };

    // Doubles the 'first' or 'second' string in state, depending on the key.
    makeMore = (key) => {
        this.setState({[key]: this.state[key] + " " + this.state[key]});
    };

    render() {
        return <div className="builderclicker">
            <h3>
                <span onClick={() => this.makeMore('first')}
                      style={{cursor: "pointer"}}
                      className="first">{this.state.first}
                </span> <span onClick={() => this.makeMore('second')}
                      style={{cursor: "pointer"}}
                      className="second">{this.state.second}</span>
            </h3>
        </div>;
    }
};

export default (props) => <BuilderClicker {...props} />;
----

{nbsp} +
*2.* `BuilderClickerEntry` is a simple entry component (since it's below `_entries`), just a container for the shared `BuilderClicker`. We will use it directly in our part, with the jsxPath `mySubfolder/BuilderClickerEntry`. But it will also be imported by a different entry, the part's own JSX. This makes no structural difference: entries can be imported by other entries, and are still entries:

.BuilderClickerEntry.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

import BuilderClicker from '../../myChunk/BuilderClicker';

export default (props) => <div className="builderclicker-entry">
		<BuilderClicker {...props} />
	</div>;
----

{nbsp} +
*3.* `04-chaining-example.jsx` is the part's internal react entry. It serves no other purpose than to demonstrate that an entry can import and nest another entry in the standard JS/react way, should you ever need to:

.04-chaining-example.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

import BuilderClickerEntry from '../../../react4xp/_entries/mySubfolder/BuilderClickerEntry';

export default (props) => <BuilderClickerEntry {...props} />;
----


{nbsp} +
*4.* `04-chaining-example.xml`, the *part definition*, doesn't do anything this time:

.04-chaining-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
	<display-name>04 - Chaining Example</display-name>
    <description>Multiple react components, chaining, nesting, hydration</description>
	<form />
</part>
----

{nbsp} +
*5.* `04-chaining-example.html`, the *part view*, is just some description, two target containers (with `id` that will be referred in the controller) and a horizontal line:

.04-chaining-example.html:
[source,html,linenums,options="nowrap"]
----
<div class="chaining-example">
    <h1>04 - Chaining Example</h1>
    <p>These two target containers existed in the HTML:</p>
    <div data-th-id="a-target-container"></div>
    <div data-th-id="another-target-container"></div>

    <hr style="display:block; margin:20px; width:100%; height:1px; border:1px dotted #aaa;"/>
    <p>The rest of the containers don't exist before rendering, but are inserted at the end:</p>
</div>
----

{nbsp} +
*6.* `04-chaining-example.es6`, the *part controller*:

.04-chaining-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const thymeleaf = require('/lib/thymeleaf');
const React4xp = require('/lib/enonic/react4xp');

const view = resolve("04-chaining-example.html");

exports.get = function(request) {

    // Renders BuilderClickerEntry, which nests BuilderClicker,
    // into the "a-target-container" element:
    const firstComp = new React4xp('mySubfolder/BuilderClickerEntry')
        .setId("a-target-container")
        .setProps({
            first: "Click",
            second: "ME!"
        });

    // Uses the component to point to and render the part-local
    // 04-chaining-example.jsx, which nests BuilderClickerEntry
    // and BuilderClicker with it, into the "another-target-container" element:
    const secondComp = new React4xp(portal.getComponent())
        .setId("another-target-container")
        .setProps({
            first: "No click ME!",
            second: "I do the exact same thing only better!"
        });

    // Creates a body starting point from the local HTML view:
    let body = thymeleaf.render(view, {});

    // Chaining: passes the body through the two components' server-side
    // rendering methods, which add passive HTML inside the two target
    // containers in it:
    body = firstComp.renderSSRIntoContainer(body);
    body = secondComp.renderSSRIntoContainer(body);

    // Chaining: creates the necessary page contributions for hydration
    // for the first component, and passes them through the second one. The
    // second turn only appends what's necessary, so that shared components
    // and dependency chunks etc aren't loaded twice:
    let pageContributions = firstComp.renderHydrationPageContributions();
    pageContributions = secondComp.renderHydrationPageContributions(pageContributions);


    // ------------------------------
    // A horizontal separator comes here in the view: a new section,
    // demonstrating a way to repeat the same entry multiple times in a part.
    // All the target containers here are generated and added to the body,
    // since the components' IDs don't match anything in the body.
    // ------------------------------


    // Creates 4 components with different props: "first repeated ID",
    // "second repeated ID", etc. Note that ALL of them are given the same ID.
    // That means they are all rendered into the same target container,
    // so only the last one will be visibly rendered:
    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {
        const notUniqueComp = new React4xp('site/parts/01-minimal-example/01-minimal-example')
            .setId('this-is-not-unique')
            .setProps({ greetee: `${cardinalNum} repeated ID`});

        body = notUniqueComp.renderTargetContainer(body);
        pageContributions = notUniqueComp.renderClientPageContributions(pageContributions);
    });

    // Same as above, but with a crucial difference: adding `.uniqueId()` to the ID
    // makes React4xp add a random-number postfix to the ID. This causes each component
    // to have a different ID, so 4 container elements are added to body instead of one
    // - and all four become visible.
    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {
        const uniqueComp = new React4xp('site/parts/01-minimal-example/01-minimal-example')
            .setId('this-id-is-unique').uniqueId()
            .setProps({ greetee: `${cardinalNum} unique ID`});

        body = uniqueComp.renderTargetContainer(body);
        pageContributions = uniqueComp.renderClientPageContributions(pageContributions);
    });

    // Returning the body/pageContribution response from the part.
    return {
        body,
        pageContributions,
    };
};
----

NOTE: In this example (line 57-78), we're making a new React4xp object for each rendering. An object can in principle be re-rendered with different props, *but rendering a body or pageContribution will lock the ID* of the object. I.e., a re-rendering of the same React4xp object will always target the same container element! Trying to change the ID will throw an error.

{nbsp} +

*Screenshot of the rendered output:*

[.thumb]
image::chaining.png["You clicked? I am but a humble screenshot." width=1036px]

Comparing this screenshot (or better, run the example and check out the actual output) with the page source below, there are a few things worth noting:

- in the actual output, the _"click me"_ components are active and clickable: clicking the first or second half of each of them doubles the clicked text, as defined in the `BuilderClicker`. This activation happened in the `.hydrate` steps (lines 58 and 64 below).
- the clicks are isolated to the component that was actually clicked: even though they are technically the same inner component `BuilderClicker` (by source), they each have their own state so when one is clicked the other one doesn't react. This is not because `BuilderClicker` is nested differently in them, but because their ID's are different,
- as predicted, since the ID was the same in all 4 renderings (line 60 in `04-chaining-example.es6`), only one container with `id="this-is-not-unique"` was added to the body (line 41 below),
- and although the four React4xp objects each add a separate `React4xp.CLIENT.render` call (lines 71, 76, 81, 86), they all target the same container, so only the last one is remains in the end,
- and since `"this-id-is-unique"` had a different postfix appended each time, all the 4 renderings created a different container (lines 42-45), and each of those are visibly rendered.
- React4xp automatically traced the dependency to `myChunk.<hash>.js` and added this import to the page contributions (line 51), because `BuilderClicker` lives there. As long as the `site` and `react4xp` folders are used for entries and dependency chunks as described, imports like this will always be handled automatically,
- and although several of the generated assets are called more than once, the page contributions are trimmed so each of them are only loaded to the client once (lines 49-56).


.Page source:
[source,html,linenums,options="nowrap"]
----
<!DOCTYPE html>
<html>
  <head></head>

  <body>

    <main data-portal-region="main" class="xp-region">
      <div data-portal-component-type="part" class="chaining-example">

        <h1>04 - Chaining Example</h1>
        <p>These two target containers existed in the HTML:</p>

        <div id="a-target-container">
          <div class="builderclicker-entry" data-reactroot="">
            <div class="builderclicker">
              <h3>
                <span style="cursor:pointer" class="first">Click</span>
                <span style="cursor:pointer" class="second">ME!</span>
              </h3>
            </div>
          </div>
        </div>

        <div id="another-target-container">
          <div class="builderclicker-entry" data-reactroot="">
            <div class="builderclicker">
              <h3>
                <span style="cursor:pointer" class="first">No click ME!</span>
                <span style="cursor:pointer" class="second">I do the exact same thing only better!</span>
              </h3>
            </div>
          </div>
        </div>

        <hr style="display:block; margin:20px; width:100%; height:1px; border:1px dotted #aaa;"></hr>

        <p>The rest of the containers didn't exist before rendering, and so, are inserted at the end:</p>
        <div id="this-is-not-unique"></div>
        <div id="this-id-is-unique_90354192"></div>
        <div id="this-id-is-unique_43124046"></div>
        <div id="this-id-is-unique_87401825"></div>
        <div id="this-id-is-unique_63865684"></div>
      </div>
    </main>

    <script src="(...) /react4xp/externals.88e80cab5.js"></script>
    <script src="(...) /react4xp-client/"></script>
    <script src="(...) /react4xp/myChunk.059c6f899.js"></script>
    <script src="(...) /react4xp/mySubfolder/BuilderClickerEntry.js"></script>
    <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script>
    <script src="(...) /react4xp/site/parts/04-chaining-example/04-chaining-example.js"></script>

    <script defer>React4xp.CLIENT.hydrate(React4xp['mySubfolder/BuilderClickerEntry'], "a-target-container", {
      "first": "Click",
      "second": "ME!",
      "react4xpId": "a-target-container"
    });</script>
    <script defer>React4xp.CLIENT.hydrate(React4xp['site/parts/04-chaining-example/04-chaining-example'], "another-target-container", {
      "first": "No click ME!",
      "second": "I do the exact same thing only better!",
      "react4xpId": "another-target-container"
    });</script>

    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "first repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "second repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "third repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "fourth repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>

    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_90354192", {
      "greetee": "first unique ID",
      "react4xpId": "this-id-is-unique_90354192"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_43124046", {
      "greetee": "second unique ID",
      "react4xpId": "this-id-is-unique_43124046"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_87401825", {
      "greetee": "third unique ID",
      "react4xpId": "this-id-is-unique_87401825"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_63865684", {
      "greetee": "fourth unique ID",
      "react4xpId": "this-id-is-unique_63865684"
    });</script>
  </body>
</html>
----



{nbsp} +
{nbsp} +

=== 5: Webapp
The last demonstration is the services `/react4xp/`, `/react4xp-client/`, `/react4xp-dependencies/` and `/react4xp-externals/`. These enable you to take advantage of React4xp components and features directly from a client-side script from scratch (except for server-side rendering, which obviously isn't available).

In the example below, we'll use XP's https://developer.enonic.com/guides/my-first-webapp[webapp] functionality with a thymeleaf template, enabling us to use `portal.serviceUrl` to get the fully prefixed URL to the services. But as long as long as you know the prefix service URL to an XP server running React4xp, you could hard code the urls if you wanted and use this feature from a completely standalone HTML.

`React4xp.CLIENT.renderWithDependencies` abstracts and simplifies all the necessary steps in rendering multiple entries into multiple target containers, including tracing and fetching entries and dependency chunks once. It needs:

- React, ReactDOM and the React4xp client wrapper must be fetched (line 5-15 below),
- The prefix service URL must be set, as a global `SERVICE_URL_ROOT` variable (line 34).

.pure.html:
[source,html,linenums,options="nowrap"]
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- OPTION 1: You can get React and ReactDOM from CDN like this... -->
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>

    <!-- OPTION 2:
      ...but React and ReactDOM are also available as a chunk from this service:
      <script data-th-src="${portal.serviceUrl({'_service=react4xp-externals'})}"></script>
    -->

    <!-- The client wrapper is needed either way: -->
    <script data-th-src="${portal.serviceUrl({'_service=react4xp-client'})}"></script>
  </head>

  <body>
    <h1>Standalone HTML</h1>

    <!-- Target containers -->
    <div id="color_thing"></div>
    <div id="clickable_thing"></div>

    <!-- Sets a global variable SERVICE_URL_ROOT.
    This is the root URL prefix to the services used
    by React4xp.CLIENT.renderWithDependencies.
    Can be set anywhere as long as it's before
    renderWithDependencies is called: -->
    <script data-th-text="|var SERVICE_URL_ROOT=`${portal.serviceUrl({'_service='})}`;|"></script>

    <!-- Actual rendering call: -->
    <script>
        React4xp.CLIENT.renderWithDependencies(

          // First parameter: an object where the keys are jsxPaths
          // (which can still be used more than once as long as the IDs
          // are unique), and the values are objects with
          // `targetId` and `props` parameters:
          {
            ColorThing: {
              targetId: 'color_thing',
              props: { color: "purple"}
            },

            'site/parts/04-chaining-example/04-chaining-example': {
              targetId: 'clickable_thing',
              props: { first: "Come On!", second: "Click Me Already!" },
            },
          },

          // Demo callback in an optional second parameter:
          function() {
              console.log("This callback is inserted and called after rendering.");
          }
        );
    </script>
  </body>
</html>
----

{nbsp} +
{nbsp} +

== API

More details can be found at https://github.com/enonic/lib-react4xp#readme[the main library docs] and the source code in that repo.

{nbsp} +

=== Controller functions

.Import:
[source,javascript,options="nowrap"]
----
const React4xp = require('/lib/enonic/react4xp');

// Equivalent: import React4xp from '/lib/enonic/react4xp';
----

{nbsp} +

.Shorthand rendering:
[source,javascript,options="nowrap"]
----
React4xp.render(request, params); <!--1-->

React4xp.renderSafe(request, params);  <!--2-->
----

<1> `React4xp.render`: *All-in-one best-practice renderer.* Renders server-side if it can, adds hydration logic for the client-side. Renders dynamic/client-side react in XP preview and live mode, and static/server-side in edit mode (XP content studio). On problems, falls back to `renderSafe`.

<2> `React4xp.renderSafe`: *Client-side and fallback renderer.* More thorough fallback and failure reporting, and avoids server-side rendering - except in edit mode, where client-side rendering is the bigger hazard.

*Both have the same signatures and returns:*

  * `request` _(object, mandatory)_ XP request object.
  * `params` _(object, mandatory)_ MUST include `jsxPath` or `component`. And if not `component`, either an `id` OR a non-falsy `uniqueId` parameter is needed. Target component file must exist. If `component` AND one of `jsxPath` or `id` are included, those data from `component` are overridden. *Subfields* in `params`:
  ** `component` _(object)_ XP component object (used to extrapolate component part and target container ID). This is sufficient if the JSX entry file is in the same folder and has the same name, and the react component doesn't need to be rendered into a particular pre-existing HTML container element.
  ** `jsxPath` _(string)_ path to react component entry, see available paths in `build/resources/main/assets/react4xp/entries.json` after building the parent project with react4xp-build-components. These are *names*, not relative paths. So jsxPath can't contain '..', '//', '/./' or start with '.' or '/'.
  ** `id` _(string, optional)_ sets the target container element id (overrides the extrapolated id if component was set). If this matches an ID in an input body, the react component will be rendered there. If not, a container with this ID will be added.
  ** `uniqueId` _(boolean|string, optional)_ If set, ensures that the ID is unique. If id is set (previous param), a random integer will be postfixed to it. If uniqueId is a string, this is the prefix before the random postfix. If the id param is used in addition to a uniqueId string, uniqueId takes presedence and overrides id.
  ** `props` _(object, optional)_ react props sent in to the component
  ** `body` _(string, optional)_ Existing HTML body, for example rendered from thymeleaf. If it already has a matching-ID target container, body passes through unchanged (use this option and the setId method to control where in the body the react component should be inserted). If it doesn't have a matching container, a matching <div> will be inserted at the end of the body, inside the root element. If body is missing, a pure-target-container body is generated and returned.
  ** `pageContributions` _(object, optional)_ Pre-existing pageContributions. New page contributions for rendering this component will be added to any pre-existing ones.

They *return* a response object that can be directly returned from an XP controller, with the fields `body` and `pageContributions`: `body` will contain a target container element for the react component. `pageContributions` will contain scripts referred by URL for running the component client-side and the component's dependencies, as well as an inline trigger script for starting the react frontend rendering into the target container. Duplicates in `pageContributions` will be removed, to avoid running identical scripts twice.


{nbsp} +

.Data object construction:
[source,javascript,options="nowrap"]
----
const comp = new React4xp(component|jsxPath);
----

The constructor has a mandatory parameter, ONE of the following two. This follows the same logic as the `component` and `jsxPath` subfields in `params` in the shorthand rendering methods above:

  * EITHER `component` _(object)_ Current-XP-component data; the output of `portal.getComponent()`. This will point to a local (same-name, same-folder as the component) react file. Derives and sets the component's `jsxPath` AND its `id` (`react4xpId`) so they don't need to be set.
  * OR `jsxPath` _(string)_ Pointer to any component. Sets the component's `jsxPath` but not the `id`.

*Returns* the constructed data-holding object (`comp`) where these fields are readable:

  * `.jsxPath` _(string)_ The jsxPath of the target react entry. The entry must exist.
  * `.props` _(object)_ Component props, if set (see below),
  * `.react4xpId` _(string)_ Component and target-container ID, if set (see below). If not set, the rendering methods will thow an error.

{nbsp} +

.Attribute setters in the data object:
[source,javascript,options="nowrap"]
----
comp.setProps(props); <!--1-->
comp.setJsxPath(jsxPath); <!--2-->
comp.setId(id); <!--3-->
comp.uniqueId(); <!--4-->

// Sequence doesn't matter (except for setId, which can overwrite a previous uniqueId).
// And a builder pattern is supported, so this would be equivalent:
//
//   comp.setProps(props)
//       .setJsxPath(jsxPath)
//       .setId(id)
//       .uniqueId();
----

<1> `setProps(props)`: `props` _(object)_ is any object serializable by `JSON.stringify`. Overwrites previous props. Props will be fed to the entry component. Even if not set explicitly, the props received by the entry component will always contain the ID, as the field `react4xpId`.
<2> `setJsxPath(jsxPath)`: `jsxPath` _(string)_ points to an entry component that must exist, jsxPath must be valid. Overwrites previous value.
<3> `setId(id)`: `id` _(string)_ Identifies the react4xp component (`comp`) and points to a target container in the DOM to receive the react rendering. Preferrably a unique element `id` in the DOM. Corresponds to `comp.react4xpId` and `props.react4xpId`.
<4> `uniqueId()`: enforces a unique element and component ID, by appending a random-number postfix. If an ID hasn't been set, it will become the random-number postfix.

All of the above *return* the object itself, enabling the builder pattern.


{nbsp} +

.Data object body HTML rendering:
[source,javascript,options="nowrap"]
----
const htmlContent = comp.renderComponentString(overrideProps); <!--1-->

const newBody = comp.renderTargetContainer(existingBody, htmlContent); <!--2-->

const newBody = comp.renderSSRIntoContainer(existingBody); <!--3-->

// Using renderSSRIntoContainer is equivalent to:
// const newBody = comp.renderTargetContainer(existingBody, comp.renderComponentString());

----

<1> `comp.renderComponentString(overrideProps)`: (server-side) renders and returns a *simple HTML string representation of the data object*, without a container or any further `body` interaction, based on the `props` currently set in the data object, or `overrideProps` _(object, optional)_ if they are set.

<2> `renderTargetContainer`: *Primary client-side body renderer*. Parameters:

  * `existingBody` _(string, optional)_ String containing HTML, and only that. If empty, a target container (with an `id` matching the ID of the data object `comp`) will be returned. If there is an HTML string but a matching-ID container is not found, a target container is added _at the end of the root element of the HTML_, i.e. just before the final closing tag. If there's a string _with_ a matching ID, nothing is changed.
  * `htmlContent` _(string, optional)_ HTML string. If empty or missing: no effect. If included, this will be injected inside the matching-ID container (that's guaranteed by the logic in the previous parameter), replacing any content that was already there. Note that in client-side rendering, `htmlContent` is usually left empty, leaving it to the client to inject some rendered content into the container.

  * *Returns* a valid HTML string, ready to be returned from a controller as the `body` field in the response - or be sent as the `existingBody` into a rendering method of a different React4xp object (see the chaining example).

<3> `renderSSRIntoContainer`: *Primary server-side body renderer*. First renders an HTML representation of the data object `comp` based on its current `props`, then injects that HTML into a (new or existing) matching-id target container in `existingBody`.  Parameters:
  * `existingBody` _(string, optional)_ Same as `existingBody` for `.renderTargetContainer`: string containing HTML, and only that. If empty, a target container (with an `id` matching the ID of the data object `comp`) will be returned. If there is an HTML string but a matching-ID container is not found, a target container is added _at the end of the root element of the HTML_, i.e. just before the final closing tag. If there's a string _with_ a matching ID, nothing is changed.

{nbsp} +

.Data object pageContributions rendering:
[source,javascript,options="nowrap"]
----
const newPageContributions = comp.renderClientPageContributions(existingPageContributions); <!--1-->

const newPageContributions = comp.renderHydrationPageContributions(existingPageContributions); <!--2-->
----

<1> `renderClientPageContributions(existingPageContributions)`: *Primary client-side pageContributions renderer*. Returns a new page contributions object, with `existingPageContributions` _(object, optional)_ added to it, and the needed pageContributions to get the client to fetch the dependencies of `comp` and render it into the matching-ID container (provided by one of the body HTML rendering methods above). This includes the entry of `comp`, all the chunks of its imported dependencies, the client-side wrapper and the _externals_, meaning client-side runnable React and ReactDOM code, the same used for the client-side rendering. Trims the pageContributions before returning them, preventing excessive loading on the client side.

<2> `renderHydrationPageContributions(existingPageContributions)`: *Primary server-side pageContributions renderer*. Identical to `.renderClientPageContributions` above, but expects that the matching-ID container already has the HTML of `comp` injected into it from the server - and then has the client trigger a https://reactjs.org/docs/react-dom.html#hydrate[react hydration] of it: activating the previously-passive HTML representation and turning it into a fully active react component.

{nbsp} +

=== Services
The four included React4xp services are exposed to the client and are central to how it fetches the assets, dependencies and the client wrapper itself. Half of what the auto-generated pageContributions are doing, uses the services. However, the services are directly usable as well. They are documented https://github.com/enonic/lib-react4xp#the-services[in the main library docs].

{nbsp} +

=== Client-side wrapper
Downloadable from the `/react4xp-client` service, is client-runnable code that wraps a few handy functions, used by the autogenerated pageContributions, but usable manually as well.

It creates a `React4xp` global object in the browser, which will contain all things React4xp. It exposes three methods under the `React4xp.CLIENT` attribute:

.Client-side wrapper functions:
[source,javascript,options="nowrap"]
----
React4xp.CLIENT.render(Component, targetId, props); // corresponds to https://reactjs.org/docs/react-dom.html#render

React4xp.CLIENT.hydrate(Component, targetId, props); // corresponds to https://reactjs.org/docs/react-dom.html#hydrate

React4xp.CLIENT.renderWithDependencies(componentsTargetsAndProps, callback, serviceUrlRoot);
----

The first two methods are 'pure' renderers. This means that in addition to the client wrapper, you need to supply and run scripts for React and ReactDOM (which are bundled in the React4xp _externals_) - and scripts for the entries as well as all their chunks, before calling `render` or `hydrate`.

However, you can also use React4xp components in a standalone html page, having only React/ReactDOM (or React4xp externals) and this client loaded in the browser: use `renderWithDependencies` as below.

{nbsp} +

==== Using `render` and `hydrate`
They both have a `(Component, targetId [, props])` signature:

  * `Component`: _(React4xp entry or any ReactDOM renderable, mandatory)_ If it's a function, the wrapper will try to turn it into a ReactDOM component by running `Component(props)`. When loading React4xp entries, they are exposed in the client as functions as part of the `React4xp` object: `React4xp[jsxPath] = (props) => Component`. A fallback has been added so that if an entry component has been compiled into a `.default` sub-attribute, the client can access the component both with and without the `default` field: if `React4xp.CLIENT.render(React4xp.myComponent.default, ...)` is strictly correct, then `React4xp.CLIENT.render(React4xp.MyComponent, ...)` will also work.
  * `targetId` _(string, mandatory)_ The unique ID of an HTML container element, into which the component will be rendered. Obviously, this must exist in the DOM when running.
  * `props`: _(object, optional)_ Top-level props that will be sent into the component. React4xp relies on serialization of this object, so _functions can't be passed in this way!_

{nbsp} +

==== Using `renderWithDependencies`
This wraps a whole chain of necessary steps: when the client has the wrapper available, you know where to contact the services (the prefix: their common URL before the service names), you have some React4xp components you want to render and know their jsxPaths and props, then `renderWithDependencies` will take care of all the gritty details needed for a client-side render, in a single call for multiple React4xp components:

  - contact the React4xp services,
  - determine what the entries' chunk dependencies are,
  - download and run those in parallel,
  - then download and run the entry scripts,
  - then run `render` on each of the entries,
  - all the time preventing duplicate downloads.

Parameters:

  * `componentsTargetsAndProps` _(object, mandatory)_ Object where each entry is similar to the `Component, targetId, [, props]` signature mentioned above: the *keys*  are jsxPath strings of React4xp entries. The *values* are objects that have a mandatory `targetId` string and an optional `props` object.
  * `callback` _(function, optional)_ This function is run after running `render`,
  * `serviceUrlRoot` _(string, optional)_ Root of the URL to the `/react4xp` and `/react4xp-dependencies` link:#_services[services]. For example, if they have the URLs `/_/service/my.app/react4xp/` and `/_/service/my.app/react4xp-dependencies/`, then `serviceRootUrl` should be `/_/service/my.app` (without a trailing slash). This is _sort of optional_: you can skip it if you define a constant `SERVICE_URL_ROOT` in global namespace before running  `renderWithDependencies` (see link:#_5_webapp[the Webapp example]). If you don't, it's a mandatory argument.


{nbsp} +
{nbsp} +

== Gotchas

=== Imports and chunks
When building your react components, *you can import JS/ES6 code as usual*: nested react components, your own secondary code, other frameworks, libraries, whatever... Imported code can be compiled into separate asset chunks from the entries that use them, for https://webpack.js.org/guides/code-splitting/[code splitting].

This chunking is easy to control: *put the imported sources in chunk-named subfolders below the `react4xp/` folder* (outside of `_entries`). Done this way, React4xp will handle:

 - optimized building and serving of the entries and chunks,
 - client-and-server-side caching with cache busting,
 - keep track of exactly which secondary chunks are needed for displaying which component entries,
 - and add the necessary client-side script requests/imports along with the response.

https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[More about entries and chunks in the core library documentation].

TIP: Chunks are more optimized than entries. Ideally, keep the served entries slim and leave the heavy lifting to chunks.

{nbsp} +

=== Rendering in different modes
Usually, it's recommended to use server-side rendering and hydration if you can. However, when using XP, it's recommended to avoid running client-side scripts in Content Studio's edit mode, as far as possible. This can be detected with `request.mode` in a controller, you can use this to control the pageContributions behavior in edit mode.

The link:#_controller_functions[shorthand rendering functions] will handle this automatically.

{nbsp} +

=== Adding/adjusting React4xp to an existing project
If you have an existing XP project you want to integrate React4xp into, the easiest way is probably to look at https://github.com/enonic/starter-react4xp/blob/master/build.gradle[build.gradle] and https://github.com/enonic/starter-react4xp/blob/master/package.json[package.json] from the starter project, and weave them into your own to add the support.

Things to keep in mind:

* `react4xp-build-components`, `react4xp-buildconstants` and `react4xp-runtime-externals` in package.json, and the line `include 'com.enonic.lib:lib-react4xp:0.3.3'` in build.gradle are all important.
* So is the React4xp configuration: lines 41-86 in build.gradle.
** The basic structure of a React4xp project, as described in this guide, is actually meant to be flexible and adjustable. See the https://www.npmjs.com/package/react4xp-buildconstants[react4xp-buildconstants docs] and tweak `REACT4XP_OVERRIDES` in build.gradle.
* The gradle task `webpack_react4xp` in build.gradle triggers a webpack build, targeting the react components and only those: `react4xp-build-components`. Here, webpack runs webpack.config.js files that are fetched from the NPM packages. This task can probably be added as-is (depending on your react build requirements).
** However, if you need a different or adjusted webpack setup, you can run `npm install` and copy the contents from `node_modules/react4xp-build-components/webpack.config.js` into a webpack config of your own, adjust that, and refer to that in build.gradle instead of the react4xp-build-components one.
** Important: if you tweak `webpack_react4xp`, make sure that this task doesn't target and transpile the "normal" XP functional source files, that'll mess things up.
* The gradle task `babelXP` in build.gradle is a pretty bare-bone setup for _only_ transpiling the "normal" XP functional files.
** Important: if you tweak `babelXP`, make sure that this task doesn't target and transpile the React4xp source files. That'll mess things up for sure.
