= React4XP project starter
:toc: right
:imagesdir: media/

Build sites and apps that support client- and serverside JSX templating with the React framework, in combination with optimized asset serving and hydration - for lighting fast sites and apps.

{nbsp} +

image::react4xp.svg["React4xp logo" width=256px]

{nbsp} +

== Introduction

React4XP integrates React with the CMS components in Content Studio, and allows reuse of JSX templates for both back-end, front-end and editorial use cases. It builds directly on top of traditional XP controllers, making JSX look like any other templating engine out there, while expanding the possibilities for single-page sites and client-side driven apps when needed.

This documentation takes you through the basic elements of React4XP and how to use the starter, helping you kickstart a React4xp project of your own.

[NOTE]
====
The starter and this guide aims for how-to, what-is and setup of React4xp with *XP 7*. An XP6-compatible version will be released shortly. If you're using XP6 and the XP6 starter, only the installation and build commands are different from XP7 - and the XP6 starter handles those differences. Using React4xp the rest of the way is identical, so *you can still use this guide for both versions.*
====

{nbsp} +
{nbsp} +

=== What is React4xp?

React4xp is a suite of tools: a library with a few companion NPM packages. They should cover many use cases, and can of course be used separately or be modified to suit your needs.

But primarily, *it's built to work together out of the box to make it as easy as possible to integrate React with Enonic XP*, by handling:

- component compilation/building,
- inserting editorial data into react components,
- isomorphic serverside and clientside rendering and hydration,
- optimizing and serving reusable asset chunks to the client side,
- component reference from anywhere

This guide focuses on the react4xp starter, which handles a full basic setup. But it can also be imported into an existing XP project - the core library docs have https://github.com/enonic/lib-react4xp/blob/master/README.md#installing-the-library[a guide for that].


{nbsp} +
{nbsp} +
{nbsp} +

== Get started

=== Create a starter project

To setup a project locally, run the following command:

  enonic project create -r starter-react4xp

Remember to create a *new XP sandbox* when completing the project wizard.

NOTE: *Don't have the Enonic CLI?* Visit the https://developer.enonic.com/start[Getting started guide] to install it.

{nbsp} +

=== Build and Deploy

To build and deploy the app, run this command from your shell:

  enonic project deploy

Accept starting the sandbox.

[NOTE]
====
To verify that your app started successfully, you should find an entry similar to this in the sandbox log:

  2019-04-09 13:40:40,765 INFO ... Application [<name.of.your.app>] installed successfully
====


{nbsp} +
{nbsp} +
{nbsp} +

== Project structure

If you're used to working with an https://developer.enonic.com/guides/my-first-webapp[ordinary] XP project with https://developer.enonic.com/templates/webpack[webpack], the structure will look familiar - the biggest news is the folder `react4xp/` under `resources/`. Your project folder should now look something like this:

.Selected files:
[source,files]
----
build.gradle <--1-->
settings.gradle <--1-->
package.json <--2-->
build/ <--3-->
src/
  main/
    resources/
      assets/ <!--4-->
      react4xp/ <!--5-->
        _entries <!--6-->
          REPLACE_ME.jsx <!--7-->
      site/
        parts/ <!--8-->
        pages/ <!--8-->
        REPLACE_ME.jsx <!--7-->
      webapp/ <!--9-->
----


<1> The gradle files are used by the build system. The starter includes some setup here: the library *lib-react4xp* and some building tasks that use webpack with configs that are fetched with NPM.
<2> `package.json` sets up NPM package import
<3> `build/` will contain output files produced by the build. All the output from the react4xp build process (along with a few housekeeping data files) will be compiled into the subfolder `build/resources/main/assets/react4xp`. These built assets are used in runtime both on client- and server side.
<4> But note that `assets/react4xp` is NOT the source of those React4xp assets! Just use `assets/` for other, general, non-react4xp static assets such as css and icons, etc.
<5> `react4xp/` is the general folder for react component source files. React4xp will look for `.js` and `.jsx` files here and in all subfolders, and compile them during build. All subfolders below this (except for `_entries` - see below) will be compiled to https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[*chunks*] with the same name as the subfolder. Put nested/reused react components in subfolders like that, and also other code imported by your components.
<6> `react4xp/_entries/` is special and magic. This is the main folder for *https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[entry components]* - react components that can be used directly by React4xp, that is, they don't need to be nested inside other react components.
<7> Two `REPLACE_ME.jsx` files: simply placeholders needed by webpack. Removed each of these when you've added one or more react source file below `react4xp/_entries/` and `site/`.
<8> Below the `site/parts/` and `site/pages/` subfolders is where you put your XP parts and pages, as always. With React4xp, *you can also put `.jsx` entry components together with your parts and pages*. This is link:#_a_shorthand_function_with_same_name_component[the easiest use case]: if they have the same name as the part/page, they are super easy to inject into the part/page from the controller.
<9> Folder containing the root webapp controller. React4xp supplies services that allow even static HTML pages to refer to and request compiled React4xp components.


{nbsp} +
{nbsp} +
{nbsp} +

== Usage

Simply put, there are *4 prototypical usage patterns*. You're not bound to use them exactly like this, and the *link:#_examples[examples]* below will show some more variation than this. But for clarity here's an overview of them:

{nbsp} +

=== A: Shorthand function with same-name component
*The easiest way* is to put one react entry sourcefile into the same folder as a part/page where it should be displayed, and let it have the same file name as the part/page (but `.JSX` extension only!).

Let the React4xp shorthand functions `.renderSafe` (for client-side rendering) or `.render` (for server-side rendering and client-side hydration) use XP's `request` and `portal.getComponent()`. Add some props the same way you would add a model when rendering Thymeleaf, and/or tweak the rendering functions with extra parameters if you want.

The output from these render functions is *a full response object with everything the client needs to display it* - HTML and page contributions. Just return it directly from the controller.

{nbsp} +

=== B: JsxPath references
If you want to *reuse an entry component in multiple parts or pages* (or just, not be bound by the parent part/page folder), put a source file where you want...

  - either a `.JS`/`.JSX`/`.ES6` under `react4xp/_entries`,
  - or a `.JSX` file in any page/part folder under `site/`,

...and use `.render` or `.renderSafe`, but instead of the object from `getComponent`, use the *https://github.com/enonic/lib-react4xp/blob/master/README.md#jsxpath-how-to-refer-to-a-react4xp-component[jsxPath] string*: a name for each entry component, built from the relative path of the JSX file below `react4xp/_entries` or `site/` - without the file extension.

NOTE: JsxPaths are not OS paths that can be used relatively. They are *name strings, and must be used in full*.

TIP: You can see all the built jsxPaths in `build/resources/main/assets/react4xp/entries.json`.

{nbsp} +

=== C: React4xp data objects
If you need *more flexibility*, or want to *use more than one entry component in a single part or page* - or even *use the same react component more than once in a part/page*:

Instead of using the shorthands `.render` or `.renderSafe`, create a temporary data-holding `new React4xp(...)` object in the page/part controller. Use a component or jsxPath argument to point to the react component. When you're done manipulating data, the React4xp object has built-in and specific methods for rendering a body and the necessary page contributions, for client-side or server-side react rendering.

These rendering methods can be *chained*, so that the output HTML or page contribution from one object is the input for the next one. This way, one response object can be built from several react components.

{nbsp} +

=== D: Client-side exposed services
Finally, React4xp can be *used outside of the page/part flow*, even without making XP controllers if needed. A few services are exposed in runtime, where a client can request runnable compiled code:

  - entries, by jsxPath reference,
  - chunks (and lists of chunks), referred by the jsxPath(s) used on a page,
  - a client-side React4xp wrapper, simplifying these manual clientside steps and triggering rendering,
  - React and ReactDOM themselves, the versions used on the serverside. Handy if you're doing SSR and want to be sure it's always the exact same versions doing the rendering everywhere.

This allows you for example to bypass Content Studio if you want, using XP's webapp functionality, making single-page react apps etc.


{nbsp} +
{nbsp} +
{nbsp} +

== Examples

These examples require a little basic experience with Enonic XP 7 (check out the excellent introductions at the https://developer.enonic.com/[Developer Portal]), and a https://developer.enonic.com/guides/my-first-site#page_component[main page component] with a https://developer.enonic.com/guides/my-first-site#regions[region].

The examples build incrementally on each other: the later, advanced examples are clearer if you've seen the previous ones.

TIP: They can be downloaded along with everything needed to run, by checking out the https://github.com/enonic/starter-react4xp/tree/examples[examples branch of starter-react4xp]

TIP: See the link:#_api[API section] below for more details about how to use what's demonstrated.

{nbsp} +

=== 1: Hello World

Let's make a simple XP part that contains a react component: `01-minimal-example`, which will be rendered entirely at the client side:

.Files involved:
[source,files]
----
site/parts/01-minimal-example/
  01-minimal-example.xml
  01-minimal-example.jsx
  01-minimal-example.es6
----

Nothing in particular is needed in *the part definition*...

.01-minimal-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>01 - Minimal Example</display-name>
  <description>Simple client-side example</description>
  <form />
</part>
----

...and *the react component* itself - the entry - is just _any standard JSX file, as long as it default-exports a function that returns a react element_. The function may optionally take a `props` object parameter - here we'll receive a `greetee` prop and gloriously greet it:

.01-minimal-example.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) => <p>Hello {props.greetee}!</p>;
----

*The controller* below imports `React4xp` and uses `.renderSafe` from it, which does a few important things here:

- Uses `request` to determine viewing mode, and choose a suitable rendering. In live mode, `renderSafe` will make a client-side rendering.
- Notes that there is no HTML `body` argument, so the JSX will be the only view to display. So `renderSafe` generates a container `body` HTML element from scratch.
- Uses the XP `component` object (from `portal.getComponent()`) to locate the JSX file in the part folder, with the part name: `01-minimal-example.jsx`. The `component` is also used to create a unique, matching react component ID for the `body` container and the client-side render command that targets it.
- Generates a response object that's directly returned from the controller, to the client. In addition to `body`, some `pageContributions` are generated and added - containing asset download links and JS rendering commands.

.01-minimal-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const component = portal.getComponent();
    const props = { greetee: "world" };

    return React4xp.renderSafe(request, { component, props });
};
----

{nbsp} +
{nbsp} +

*That's it. Now let's add this part to a page in Content Studio and render it!*

Run `enonic project deploy` from your shell, start the sandbox and direct your browser to `localhost:8080/admin`. Log in to XP and open Content Studio. If you haven't already, create some content (a site or the included landing page type will do) that uses a page controller with a region. Insert a new part, and select the minimal-example part you just made. Edit it, give it a displayname, save it and enter the preview:

[.thumb]
image::hello-world.png["Glorious greeting of the very existence itself!" width=492px]

If we view the page source code in the browser (and format it and strip away some irrelevant parts), we'll see something like this:
[source,html,options="nowrap"]
----
<!DOCTYPE html>
<html>
  <head>(...)</head>

  <body>

    <main data-portal-region="main" class="xp-region">
      <div (...) id="parts_01-minimal-example__main_0"></div> <!--1-->
    </main>

    <script src="(...) /react4xp/externals.88e80cab5.js"></script>  <!--2-->
    <script src="(...) /react4xp-client/"></script> <!--3-->
    <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--4-->
    <script defer> <!--5-->
      React4xp.CLIENT.render(
        React4xp['site/parts/01-minimal-example/01-minimal-example'],
        "parts_01-minimal-example__main_0",
        { "greetee": "world", "react4xpId": "parts_01-minimal-example__main_0" }
      );
    </script>
   </body>
</html>
----

The important lines here are all added by `.renderSafe` in the part:

<1> The generated target container element (`body`), with an ID. It's empty for now, it won't be filled with "Hello World" before the rendering is triggered.
<2> Downloading React and ReactDOM in an `externals` chunk (the exact path varies with local setups, so it's truncated to `(...)`). When this is run, `React` and `ReactDOM` are globally available in the client.
<3> Downloading the react4xp client wrapper, which enables the rendering command in point #5, among other things. Creates a global client-side object, `React4xp`, which will contain all things React4xp in runtime. The client wrapper is `React4xp.CLIENT`.
<4> Downloading the react component itself - the autocompiled version of `01-minimal-example.jsx`. The runtime-renderable component is put into `React4xp.<jsxPath>`, in this case: `React4xp['site/parts/01-minimal-example/01-minimal-example']`.
<5> A client rendering command `React4xp.CLIENT.render` is generated and triggered, with some arguments: A pointer to the react component, the ID of the element to render the component into, and the props. Note that we only added the `greetee` prop. The other one, `React4xpId`, is the unique ID of the component, same as the element target. It's always added as a react prop for the component. Occasionally handy!

{nbsp} +
{nbsp} +

=== 2: Serverside rendering

In this example we'll create a new part, similar to the link:#_1_hello_world[first] one but with these differences:

- Server-side rendering with hydration: `.render` instead of `.renderSafe`. They have the same parameter signature, but we'll also use it slightly differently here with some manual options:
- A thymeleaf HTML view already exists, and we're rendering the react component into a target container element in it,
- We're not using a 'local' JSX component inside the part. Instead, we're using the `jsxPath` to point elsewhere; to reuse the react entry from the first example.
- We're setting the ID manually, instead of letting `.render` generate it.
- Since we're manually setting both the ID and the jsxPath pointer, we don't need the `component` parameter.
- However, we'll inject some editorial data into the react commponent, using the props. We'll use `getComponents` to fetch those.

.Files involved:
[source,files]
----
site/parts/
  01-minimal-example/
    01-minimal-example.jsx
  02-serverside-example/
    02-serverside-example.xml
    02-serverside-example.html
    02-serverside-example.es6
----

Still an unremarkable *part definition*, but now there's a `greetee` TextLine input field. Here we'll enter something editorial in Content Studio, fetch it in the controller and inject it into the react component.

.02-serverside-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>02 - Server-Side Example</display-name>
  <description>Server-side rendered react component</description>
  <form>
    <input name="greetee" type="TextLine">
      <label>What should be our greeting (after 'Hello')?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>world</default>
    </input>
  </form>
</part>
----

*The view* demonstrates how a target container can be anywhere in an HTML file, and still receive the react injection - same as in vanilla react - as long as we point to it with the ID: `serverside-example-container`.

NOTE: If `.render` or `.renderSafe` are given a `body` to inject react into, but there's no element in the HTML with an `id` that matches the `React4xpId` of the component, a new, empty container with a matching `id` will be added inside the `body`, at the end. In this case it would be injected between line 5 and 6:

.02-serverside-example.html
[source,html,linenums,options="nowrap"]
----
<div class="serverside-example">
    <h2>Server-side rendering example</h2>
    <p>Server-side rendered and hydrated, inserted below:</p>
    <div id="serverside-example-container"></div>
    <p>(SSR example is done).</p>
</div>
----

As usual, the important React4xp stuff happens in *the part controller*:

.02-serverside-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

// View file
const view = resolve('02-serverside-example.html');

exports.get = function(request) {
    // Fetching the component data we entered (or, we're about to)
    // in the textfield in Content Studio:
    const component = portal.getComponent();

    // The `.render` shorthand method produces a server-side rendering. <!--1-->
    return React4xp.render(
        request, // `request` is still used to determine viewing mode.
        {
            // Extracting `greetee` from the component data,
            // and setting the value as the `greetee` prop
            props: { greetee: component.config.greetee },

            // Uses jsxPath to use the react entry from the previous
            // example, `01-minimal-example.jsx`. <!--2-->
            jsxPath: 'site/parts/01-minimal-example/01-minimal-example',

            // Manually setting the component's `React4xpId`,
            // identical to the `id` of the rendering target container.
            id: 'serverside-example-container',

            // The `body` parameter is an HTML string.
            // Here, itâ€™s rendered by Thymeleaf based on the view file. <!--3-->
            body: thymeleaf.render(view, {})
        }
    );
};
----

Notes:

<1> In live view, `.render` also *hydrates* the rendered HTML - post-filling it with the active react and JS functionality on the client

<2> This *jsxPath structure* is common for all JSX entries below the `site/` folder: `site/<parts-or-pages>/<part-or-page-folder-name>/<filename>`.

<3> *Body and pageContributions parameters:* The `body` and `pageContributions` parameters are *pass-through*! Had this been the `.renderSafe` client-side rendering function, `body` would just have become the `body` in the response output, only with a container element added (possibly. Nothing's added if a matching-`id` element is found in it). But with `.render`, the react component is rendered to HTML by the server using the initial `props`, and inserted into the target container in `body` (which, again, might be a generated target container if the input HTML is missing one). This modified `body` is then returned. On the client, `.render` will `.hydrate` the container, filling in and activating the react component. The `pageContributions` parameter isn't shown here, but works the same way: appending the React4xp output pageContributions to the input ones, if any were given. See the next example.

{nbsp} +
{nbsp} +

*Okay, enough code - let's run the example!*

Add the new part `02-serverside-example` to our page in Content Studio (the way we did in link:#\_1_hello_world[the previous example]). When we edit the part and open the _inspect_ panel on the right, we see the TextField asking us _"What should be our greeting?"_ It suggests _"world"_, but for variation we'll enter _"from the server side"_. This is the `greetee` value, it gets prop'ed into the react component, and we can see the rendered result in the preview on the left:

[.thumb]
image::editing-serverside.png["" width=1037px]

The output page source from the server is very similar to the previous example:
[source,html,options="nowrap"]
----
<body>
  <main data-portal-region="main" class="xp-region">

    <div class="serverside-example">
      <h2>Server-side rendering example</h2>
      <p>Server-side rendered and hydrated, inserted below:</p>
      <div id="serverside-example-container">
        <p data-reactroot="">Hello <!-- -->from the server side<!-- -->!</p> <!--1-->
      </div>
      <p>(SSR example is done).</p>
    </div>

  </main>

  <script src="(...) /react4xp/externals.88e80cab5.js" ></script>
  <script src="(...) /react4xp-client/" ></script>
  <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--2-->
  <script defer> <!--3-->
    React4xp.CLIENT.hydrate(
      React4xp['site/parts/01-minimal-example/01-minimal-example'],
      "serverside-example-container" ,
      {"greetee":"from the server side","react4xpId":"serverside-example-container"}
    );
  </script>
</body>
----

Most noteworthy:

<1> The target container is not initially empty anymore, but contained rendered HTML from the server.
<2> The imported entry is still the same as in the previous example. This is the compiled version of the JSX component we pointed to with `jsxPath` in the controller.
<3> Instead of `.render`, we're triggering `.hydrate`. Here, that doesn't make a difference since our react component doesn't have any more active stuff in it than just outputting an HTML string. But had it had things like event listeners, state, connections to thirdparty libraries etc, `.hydrate` would have hooked those up to the DOM structure created in the target container element, creating a working, active component.

TIP: Server-side rendering can take a long time to produce an output on the first rendering (several seconds). This should happen _very rarely or never_ after the first rendering on the server. What happens is that the component is parsed, compiled and cached on the server. After that, repeated renderings even with different props are very fast!

{nbsp} +
{nbsp} +

=== 3: React4xp objects

Here we won't use the shorthand functions `.render` or `.renderSafe`. Instead, we'll use the explicit syntax that the shorthand functions use under the hood. We'll construct a data-holding React4xp object, and use its built-in methods to specifically and separately render the `body` and the `pageContributions`.

This provides more fine-grained control and opportunities for logic steps during the component creation.

Other new features demonstrated:

- The controller as the source of the target container ID, injecting it both into the view and the react component,
- Referring to a React component outside of XP's `/site/` structure, in the base directory `/react4xp/\_entries`,
- Rendering a `body` with Thymeleaf once, and using it as a static pre-rendered template.
- Making some raw XP pageContributions before rendering, with a script with inserted editorial data. Then passing that `pageContributions` object through the `.renderClientPageContributions`, and getting new pageContributions (which activate the react component as we did before) added to it - retaining the existing pageContributions.

.Files involved:
[source,files]
----
react4xp/_entries/
  ColorThing.jsx
site/parts:
  /03-customflow-example/
    03-customflow-example.xml
    03-customflow-example.html
    03-customflow-example.es6
----

As usual, we start with the *part definition*, and it's still the source of some editorial data: `color`.

.03-customflow-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>03 - CustomFlow Example</display-name>
  <description>AKA. The Color Thing</description>
  <form>
    <input name="color" type="TextLine">
      <label>What's the color of the thing?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>red</default>
    </input>
  </form>
</part>
----

Next, let's look at the *react component*. Still not very advanced, but at least it's colorful (sorry):

.ColorThing.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) =>
  <div style={{border: `1px dotted ${props.color}`,margin:"5px",padding:"5px" }}>
    <h2>The {props.color} thing</h2>
    <p style={{color: props.color}}>Hey, I'm pretty {props.color}!</p>
  </div>;
----

The thymeleaf *view* has no other purpose than to show that an ID is inserted, turning this into a target container:

.03-customflow-example.html
[source,html,linenums,options="nowrap"]
----
<div data-th-id="${targetId}"></div>
----

Finally, *the controller*:

.03-customflow-example.es6:
[source,javascript,linenums,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

// Sets the ID for both the react component and the target container...
const TARGET_ID = "color-greeter-id";

const view = resolve('03-customflow-example.html');
const model = {
    targetId: TARGET_ID
};
// ... which is rendered to a static HTML string here and only once:
const PRE_RENDERED_BODY_TEMPLATE = thymeleaf.render(view, model);

exports.get = function(request) {
    const component = portal.getComponent();

    // Constructor for a React4xp object, setting one mandatory parameter:
    // either an XP component object, or as in this case: a jsxPath string. <!--1-->
    const reactComp = new React4xp('ColorThing');

    // Builder pattern for setting the additional optional attributes. <!--2-->
    reactComp
        .setId(TARGET_ID)
        .setProps({
            color: component.config.color
        });

	// Making a normal XP pageContributions object <!--3-->
	const preExistingPageContributions = {
        bodyEnd: `<script>
            console.log('Okay, rendered the ${reactComp.props.color} thing.');
        </script>`
    };

    // Without the shorthand rendering, there are separate rendering
    // functions for body and pageContributions: <!--4-->
    return {
        // `.renderTargetContainer` renders ONLY the target container
        // - no server-side added react content. <!--5-->
        body: reactComp.renderTargetContainer(PRE_RENDERED_BODY_TEMPLATE),

        // `.renderClientPageContributions` only makes
        // client-side rendering script tags. <!--6-->
        pageContributions: reactComp.renderClientPageContributions(
            preExistingPageContributions
        )
    }
};
----

Footnotes from the comments:

<1> Why is `ColorThing`, and only that, the jsxPath to `ColorThing.jsx`? Because it's at the root level of the magic react4xp-entries base folder: `src/main/resources/react4xp/_entries`.

<2> The builder pattern means these optional methods can be chained like in the example or happen separately - in any sequence. The example lines here are equivalent to:

	reactComp.setProps({color: component.config.color});
	reactComp.setId(TARGET_ID);

<3> The `props` are already set in the React4xp `reactComp` object. We can fetch attributes from it before the rendering, in this case reading the `color` prop and injecting it into this mini-script.

<4> So there's no automatic selection of rendering mode. *Try to avoid active client-side JS running in Content Studio's edit mode*. Take care when rendering manually like this. The simplest way is to detect the viewing mode from the `request` object and skip the pageContributions.

<5> `.renderTargetContainer` can be used without an argument. It will then simply generate an empty target container for you, with an `id` matching the react components ID.

<6> We're passing `preExistingPageContributions` _through_ `.renderClientPageContributions`, keeping the script line we made and adding the component's necessary pageContributions to it when it's returned. This method can also be run without an argument, giving you fresh pageContributions.

{nbsp} +

*Okay, let's take a look:*
As before, open Enonic XP, make a new part, select the new part we made: 03-Customflow Example. Edit the part config, and change the color of the thing, for example to "blue". Save, and open the preview.

Unsurprisingly, we should get something like this:

[.thumb]
image::the-blue-thing.png["" width=1068px]

We also see in the console that the little `console.log` script from the controller has picked up the `color` prop _from_ the object, and passed through the `.renderClientPageContributions`, only joined by the generated JS that the client uses to render the blue thing. The rest of the output follows the same logic as we've seen before for a client-side rendering:

[source,html,options="nowrap"]
----
<body>
  <main data-portal-region="main" class="xp-region">
    <div id="color-greeter-id"></div>
  </main>

  <script src="(...) /react4xp/externals.88e80cab5.js"></script>
  <script src="(...) /react4xp-client/"></script>

  <script>console.log('Okay, rendered the blue thing.');</script>

  <script src="(...) /react4xp/ColorThing.js"></script>
  <script defer>
    React4xp.CLIENT.render(
      React4xp['ColorThing'],
      "color-greeter-id",
      { "color": "blue", "react4xpId": "color-greeter-id" }
    );
  </script>
</body>
----

{nbsp} +
{nbsp} +

=== 4: A part with multiple react components, chaining, nesting, hydration

A more complex example, where we'll look at using *multiple react components in a single part* - including reusing multiple instances of _the same_ react component and making them unique within the part:

- rendering a stateful component, more powerful than before,
- ...which is serverside-rendered as a passive string and then activated in the client with `.hydrate`,
- chaining (passing the body and pageContributions through multiple react4xp data objects),
- nesting shared, non-entry react components in an entry,
- how `import`-ing non-entry code results in a predictable chunk structure,

.Files involved:
[source,files]
----
react4xp/
  myChunk/
    BuilderClicker.jsx <!--1-->
  _entries/
    mySubfolder/
      BuilderClickerEntry.jsx <!--2-->
site/parts:
  /04-chaining-example/
    04-chaining-example.jsx <!--3-->
    04-chaining-example.xml <!--4-->
    04-chaining-example.html <!--5-->
    04-chaining-example.es6 <!--6-->
----

{nbsp} +
*1.* `BuilderClicker` is a shared react component that will be imported by `BuilderClickerEntry` and put inside the chunk `myChunk.<hash>.js` - because it's below the `myChunk` subfolder instead of `_entries`. *As a non-entry, it will not get a jsxPath*, so it will be better optimized but must be imported by an entry to be used in React4xp. It's also a *stateful and active* react component: the props are stored and output after one another in a `<h3>` element, and can be changed: each of them are repeated/doubled when clicked in the client (so repeated clicks will build a lot of text, hence the name):

.BuilderClicker.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

class BuilderClicker extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            first: props.first,
            second: props.second,
        }
    };

    // Doubles the 'first' or 'second' string in state, depending on the key.
    makeMore = (key) => {
        this.setState({[key]: this.state[key] + " " + this.state[key]});
    };

    render() {
        return <div className="builderclicker">
            <h3>
                <span onClick={() => this.makeMore('first')}
                      style={{cursor: "pointer"}}
                      className="first">{this.state.first}
                </span> <span onClick={() => this.makeMore('second')}
                      style={{cursor: "pointer"}}
                      className="second">{this.state.second}</span>
            </h3>
        </div>;
    }
};

export default (props) => <BuilderClicker {...props} />;
----

{nbsp} +
*2.* `BuilderClickerEntry` is a simple entry component (since it's below `_entries`), just a container for the shared `BuilderClicker`. We will use it directly in our part, with the jsxPath `mySubfolder/BuilderClickerEntry`. But it will also be imported by a different entry, the part's own JSX. This makes no structural difference: entries can be imported by other entries, and are still entries:

.BuilderClickerEntry.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

import BuilderClicker from '../../myChunk/BuilderClicker';

export default (props) => <div className="builderclicker-entry">
		<BuilderClicker {...props} />
	</div>;
----

{nbsp} +
*3.* `04-chaining-example.jsx` is the part's internal react entry. It serves no other purpose than to demonstrate that an entry can import and nest another entry in the standard JS/react way, should you ever need to:

.04-chaining-example.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

import BuilderClickerEntry from '../../../react4xp/_entries/mySubfolder/BuilderClickerEntry';

export default (props) => <BuilderClickerEntry {...props} />;
----


{nbsp} +
*4.* `04-chaining-example.xml`, the *part definition*, doesn't do anything this time:

.04-chaining-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
	<display-name>04 - Chaining Example</display-name>
    <description>Multiple react components, chaining, nesting, hydration</description>
	<form />
</part>
----

{nbsp} +
*5.* `04-chaining-example.html`, the *part view*, is just some description, two target containers (with `id` that will be referred in the controller) and a horizontal line:

.04-chaining-example.html:
[source,html,linenums,options="nowrap"]
----
<div class="chaining-example">
    <h1>04 - Chaining Example</h1>
    <p>These two target containers existed in the HTML:</p>
    <div data-th-id="a-target-container"></div>
    <div data-th-id="another-target-container"></div>

    <hr style="display:block; margin:20px; width:100%; height:1px; border:1px dotted #aaa;"/>
    <p>The rest of the containers don't exist before rendering, but are inserted at the end:</p>
</div>
----

{nbsp} +
*6.* `04-chaining-example.es6`, the *part controller*:

.04-chaining-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const thymeleaf = require('/lib/thymeleaf');
const React4xp = require('/lib/enonic/react4xp');

const view = resolve("04-chaining-example.html");

exports.get = function(request) {

    // Renders BuilderClickerEntry, which nests BuilderClicker,
    // into the "a-target-container" element:
    const firstComp = new React4xp('mySubfolder/BuilderClickerEntry')
        .setId("a-target-container")
        .setProps({
            first: "Click",
            second: "ME!"
        });

    // Uses the component to point to and render the part-local
    // 04-chaining-example.jsx, which nests BuilderClickerEntry
    // and BuilderClicker with it, into the "another-target-container" element:
    const secondComp = new React4xp(portal.getComponent())
        .setId("another-target-container")
        .setProps({
            first: "No click ME!",
            second: "I do the exact same thing only better!"
        });

    // Creates a body starting point from the local HTML view:
    let body = thymeleaf.render(view, {});

    // Chaining: passes the body through the two components' server-side
    // rendering methods, which add passive HTML inside the two target
    // containers in it:
    body = firstComp.renderSSRIntoContainer(body);
    body = secondComp.renderSSRIntoContainer(body);

    // Chaining: creates the necessary page contributions for hydration
    // for the first component, and passes them through the second one. The
    // second turn only appends what's necessary, so that shared components
    // and dependency chunks etc aren't loaded twice:
    let pageContributions = firstComp.renderHydrationPageContributions();
    pageContributions = secondComp.renderHydrationPageContributions(pageContributions);


    // ------------------------------
    // A horizontal separator comes here in the view: a new section,
    // demonstrating a way to repeat the same entry multiple times in a part.
    // All the target containers here are generated and added to the body,
    // since the components' IDs don't match anything in the body.
    // ------------------------------


    // Creates 4 components with different props: "first repeated ID",
    // "second repeated ID", etc. Note that ALL of them are given the same ID.
    // That means they are all rendered into the same target container,
    // so only the last one will be visibly rendered:
    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {
        const notUniqueComp = new React4xp('site/parts/01-minimal-example/01-minimal-example')
            .setId('this-is-not-unique')
            .setProps({ greetee: `${cardinalNum} repeated ID`});

        body = notUniqueComp.renderTargetContainer(body);
        pageContributions = notUniqueComp.renderClientPageContributions(pageContributions);
    });

    // Same as above, but with a crucial difference: adding `.uniqueId()` to the ID
    // makes React4xp add a random-number postfix to the ID. This causes each component
    // to have a different ID, so 4 container elements are added to body instead of one
    // - and all four become visible.
    ['first', 'second', 'third', 'fourth'].forEach(cardinalNum => {
        const uniqueComp = new React4xp('site/parts/01-minimal-example/01-minimal-example')
            .setId('this-id-is-unique').uniqueId()
            .setProps({ greetee: `${cardinalNum} unique ID`});

        body = uniqueComp.renderTargetContainer(body);
        pageContributions = uniqueComp.renderClientPageContributions(pageContributions);
    });

    // Returning the body/pageContribution response from the part.
    return {
        body,
        pageContributions,
    };
};
----

NOTE: In this example (line 57-78), we're making a new React4xp object for each rendering. An object can in principle be re-rendered with different props, *but rendering a body or pageContribution will lock the ID* of the object. I.e., a re-rendering of the same React4xp object will always target the same container element! Trying to change the ID will throw an error.

{nbsp} +

*Screenshot of the rendered output:*

[.thumb]
image::chaining.png["You clicked? I am but a humble screenshot." width=1036px]

Comparing this screenshot (or better, run the example and check out the actual output) with the page source below, there are a few things worth noting:

- in the actual output, the _"click me"_ components are active and clickable: clicking the first or second half of each of them doubles the clicked text, as defined in the `BuilderClicker`. This activation happened in the `.hydrate` steps (lines 58 and 64).
- the clicks are isolated to the component that was actually clicked: even though they are technically the same inner component `BuilderClicker` (by source), they each have their own state so when one is clicked the other one doesn't react. This is not because `BuilderClicker` is nested differently in them, but because their ID's are different,
- as predicted, since the ID was the same in all 4 renderings (line 60 in `04-chaining-example.es6`), only one container with `id="this-is-not-unique"` was added to the body (line 41 below),
- and although the four React4xp objects each add a separate `React4xp.CLIENT.render` call (lines 71, 76, 81, 86), they all target the same container, so only the last one is remains in the end,
- and since `"this-id-is-unique"` had a different postfix appended each time, all the 4 renderings created a different container (lines 42-45), and each of those are visibly rendered.
- React4xp automatically traced the dependency to `myChunk.<hash>.js` and added this import to the page contributions (line 51), because `BuilderClicker` lives there. As long as the `site` and `react4xp` folders are used for entries and dependency chunks as described, imports like this will always be handled automatically,
- and although several of the generated assets are called more than once, the page contributions are trimmed so each of them are only loaded to the client once (lines 49-56).


.Page source:
[source,html,linenums,options="nowrap"]
----
<!DOCTYPE html>
<html>
  <head></head>

  <body>

    <main data-portal-region="main" class="xp-region">
      <div data-portal-component-type="part" class="chaining-example">

        <h1>04 - Chaining Example</h1>
        <p>These two target containers existed in the HTML:</p>

        <div id="a-target-container">
          <div class="builderclicker-entry" data-reactroot="">
            <div class="builderclicker">
              <h3>
                <span style="cursor:pointer" class="first">Click</span>
                <span style="cursor:pointer" class="second">ME!</span>
              </h3>
            </div>
          </div>
        </div>

        <div id="another-target-container">
          <div class="builderclicker-entry" data-reactroot="">
            <div class="builderclicker">
              <h3>
                <span style="cursor:pointer" class="first">No click ME!</span>
                <span style="cursor:pointer" class="second">I do the exact same thing only better!</span>
              </h3>
            </div>
          </div>
        </div>

        <hr style="display:block; margin:20px; width:100%; height:1px; border:1px dotted #aaa;"></hr>

        <p>The rest of the containers didn't exist before rendering, and so, are inserted at the end:</p>
        <div id="this-is-not-unique"></div>
        <div id="this-id-is-unique_90354192"></div>
        <div id="this-id-is-unique_43124046"></div>
        <div id="this-id-is-unique_87401825"></div>
        <div id="this-id-is-unique_63865684"></div>
      </div>
    </main>

    <script src="(...) /react4xp/externals.88e80cab5.js"></script>
    <script src="(...) /react4xp-client/"></script>
    <script src="(...) /react4xp/myChunk.059c6f899.js"></script>
    <script src="(...) /react4xp/mySubfolder/BuilderClickerEntry.js"></script>
    <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script>
    <script src="(...) /react4xp/site/parts/04-chaining-example/04-chaining-example.js"></script>

    <script defer>React4xp.CLIENT.hydrate(React4xp['mySubfolder/BuilderClickerEntry'], "a-target-container", {
      "first": "Click",
      "second": "ME!",
      "react4xpId": "a-target-container"
    });</script>
    <script defer>React4xp.CLIENT.hydrate(React4xp['site/parts/04-chaining-example/04-chaining-example'], "another-target-container", {
      "first": "No click ME!",
      "second": "I do the exact same thing only better!",
      "react4xpId": "another-target-container"
    });</script>

    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "first repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "second repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "third repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-is-not-unique", {
      "greetee": "fourth repeated ID",
      "react4xpId": "this-is-not-unique"
    });</script>

    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_90354192", {
      "greetee": "first unique ID",
      "react4xpId": "this-id-is-unique_90354192"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_43124046", {
      "greetee": "second unique ID",
      "react4xpId": "this-id-is-unique_43124046"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_87401825", {
      "greetee": "third unique ID",
      "react4xpId": "this-id-is-unique_87401825"
    });</script>
    <script defer>React4xp.CLIENT.render(React4xp['site/parts/01-minimal-example/01-minimal-example'], "this-id-is-unique_63865684", {
      "greetee": "fourth unique ID",
      "react4xpId": "this-id-is-unique_63865684"
    });</script>
  </body>
</html>
----



{nbsp} +
{nbsp} +

=== 5: Webapp
The last demonstration is the services `/react4xp/`, `/react4xp-client/`, `/react4xp-dependencies/` and `/react4xp-externals/`. These enable you to take advantage of React4xp components and features directly from a client-side script from scratch (except for server-side rendering, which obviously isn't available).

In the example below, we'll use XP's https://developer.enonic.com/guides/my-first-webapp[webapp] functionality with a thymeleaf template, enabling us to use `portal.serviceUrl` to get the fully prefixed URL to the services. But as long as long as you know the prefix service URL to an XP server running React4xp, you could hard code the urls if you wanted and use this feature from a completely standalone HTML.

`React4xp.CLIENT.renderWithDependencies` abstracts and simplifies all the necessary steps in rendering multiple entries into multiple target containers, including tracing and fetching entries and dependency chunks once. It needs:

- React, ReactDOM and the React4xp client wrapper must be fetched (line 5-15 below),
- The prefix service URL must be set, as a global `SERVICE_URL_ROOT` variable (line 34).

.pure.html:
[source,html,linenums,options="nowrap"]
----
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- OPTION 1: You can get React and ReactDOM from CDN like this... -->
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>

    <!-- OPTION 2:
      ...but React and ReactDOM are also available as a chunk from this service:
      <script data-th-src="${portal.serviceUrl({'_service=react4xp-externals'})}"></script>
    -->

    <!-- The client wrapper is needed either way: -->
    <script data-th-src="${portal.serviceUrl({'_service=react4xp-client'})}"></script>
  </head>

  <body>
    <h1>Standalone HTML</h1>

    <!-- Target containers -->
    <div id="color_thing"></div>
    <div id="clickable_thing"></div>

    <!-- Sets a global variable SERVICE_URL_ROOT.
    This is the root URL prefix to the services used
    by React4xp.CLIENT.renderWithDependencies.
    Can be set anywhere as long as it's before
    renderWithDependencies is called: -->
    <script data-th-text="|var SERVICE_URL_ROOT=`${portal.serviceUrl({'_service='})}`;|"></script>

    <!-- Actual rendering call: -->
    <script>
        React4xp.CLIENT.renderWithDependencies(

          // First parameter: an object where the keys are jsxPaths
          // (which can still be used more than once as long as the IDs
          // are unique), and the values are objects with
          // `targetId` and `props` parameters:
          {
            ColorThing: {
              targetId: 'color_thing',
              props: { color: "purple"}
            },

            'site/parts/04-chaining-example/04-chaining-example': {
              targetId: 'clickable_thing',
              props: { first: "Come On!", second: "Click Me Already!" },
            },
          },

          // Demo callback in an optional second parameter:
          function() {
              console.log("This callback is inserted and called after rendering.");
          }
        );
    </script>
  </body>
</html>
----

{nbsp} +
{nbsp} +

== API and details

More details can be found at https://github.com/enonic/lib-react4xp#readme[the main library docs] and the source code in that repo.

{nbsp} +

=== API

==== React4xp

.Import:
[source,javascript,options="nowrap"]
----
// Equivalent: import React4xp from '/lib/enonic/react4xp';
const React4xp = require('/lib/enonic/react4xp');
----

{nbsp} +

.Shorthand rendering:
[source,javascript,options="nowrap"]
----
React4xp.render(request, params); <!--1-->

React4xp.renderSafe(request, params);  <!--2-->
----

<1> `React4xp.render`: *All-in-one best-practice renderer.* Renders server-side if it can, adds hydration logic for the client-side. Renders dynamic/client-side react in XP preview and live mode, and static/server-side in edit mode (XP content studio). On problems, falls back to `renderSafe`.

<2> `React4xp.renderSafe`: *Client-side and fallback renderer.* More thorough fallback and failure reporting, and avoids server-side rendering - except in edit mode, where client-side rendering is the bigger hazard.

*Both have the same signatures and returns:*

  * `request` _(object, mandatory)_ XP request object.
  * `params` _(object, mandatory)_ MUST include `jsxPath` or `component`. And if not `component`, either an `id` OR a non-falsy `uniqueId` parameter is needed. Target component file must exist. If `component` AND one of `jsxPath` or `id` are included, those data from `component` are overridden. *Subfields* in `params`:
  ** `component` _(object)_ XP component object (used to extrapolate component part and target container ID). This is sufficient if the JSX entry file is in the same folder and has the same name, and the react component doesn't need to be rendered into a particular pre-existing HTML container element.
  ** `jsxPath` _(string)_ path to react component entry, see available paths in `build/resources/main/assets/react4xp/entries.json` after building the parent project with react4xp-build-components. These are *names*, not relative paths. So jsxPath can't contain '..', '//', '/./' or start with '.' or '/'.
  ** `id` _(string, optional)_ sets the target container element id (overrides the extrapolated id if component was set). If this matches an ID in an input body, the react component will be rendered there. If not, a container with this ID will be added.
  ** `uniqueId` _(boolean|string, optional)_ If set, ensures that the ID is unique. If id is set (previous param), a random integer will be postfixed to it. If uniqueId is a string, this is the prefix before the random postfix. If the id param is used in addition to a uniqueId string, uniqueId takes presedence and overrides id.
  ** `props` _(object, optional)_ react props sent in to the component
  ** `body` _(string, optional)_ Existing HTML body, for example rendered from thymeleaf. If it already has a matching-ID target container, body passes through unchanged (use this option and the setId method to control where in the body the react component should be inserted). If it doesn't have a matching container, a matching <div> will be inserted at the end of the body, inside the root element. If body is missing, a pure-target-container body is generated and returned.
  ** `pageContributions` _(object, optional)_ Pre-existing pageContributions. New page contributions for rendering this component will be added to any pre-existing ones.

They *return* a response object that can be directly returned from an XP controller, with the fields `body` and `pageContributions`: `body` will contain a target container element for the react component. `pageContributions` will contain scripts referred by URL for running the component client-side and the component's dependencies, as well as an inline trigger script for starting the react frontend rendering into the target container. Duplicates in `pageContributions` will be removed, to avoid running identical scripts twice.

{nbsp} +

=== Imports and chunks
When building your react components, *you can import JS/ES6 code as usual*: nested react components, your own secondary code, other frameworks, libraries, whatever... Imported code can be compiled into separate asset chunks from the entries that use them, for https://webpack.js.org/guides/code-splitting/[code splitting].

This chunking is easy to control: *put the imported sources in chunk-named subfolders below the `react4xp/` folder* (outside of `_entries`). Done this way, React4xp will handle:

 - optimized building and serving of the entries and chunks,
 - client-and-server-side caching with cache busting,
 - keep track of exactly which secondary chunks are needed for displaying which component entries,
 - and add the necessary client-side script requests/imports along with the response.

https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[More about entries and chunks in the core library documentation].

TIP: Chunks are more optimized than entries. Ideally, keep the served entries slim and leave the heavy lifting to chunks.

{nbsp} +

==== Rendering in different modes

{nbsp} +

=== Adjusting the setup

adjusting pieces of the build
	webpack.configs from NPM packages
	constants: project structure
	externals, mtp SSR
	packages and versions

