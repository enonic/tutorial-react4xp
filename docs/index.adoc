= React4XP project starter
:toc: right
:imagesdir: media/

Build sites and apps that support client- and serverside JSX templating with the React framework, in combination with optimized asset serving and hydration - for lighting fast sites and apps.

{nbsp} +

image::react4xp.svg["React4xp logo" width=256px]

{nbsp} +

== Introduction

React4XP integrates React with the CMS components in Content Studio, and allows reuse of JSX templates for both back-end, front-end and editorial use cases. It builds directly on top of traditional XP controllers, making JSX look like any other templating engine out there, while expanding the possibilities for single-page sites and client-side driven apps when needed.

This documentation takes you through the basic elements of React4XP and how to use the starter, helping you kickstart a React4xp project of your own.

[NOTE]
====
The starter and this guide aims for how-to, what-is and setup of React4xp with *XP 7*. An XP6-compatible version will be released shortly. If you're using XP6 and the XP6 starter, only the installation and build commands are different from XP7 - and the XP6 starter handles those differences. Using React4xp the rest of the way is identical, so *you can still use this guide for both versions.*
====

{nbsp} +
{nbsp} +

=== What is React4xp?

React4xp is a suite of tools: a library with a few companion NPM packages. They should cover many use cases, and can of course be used separately or be modified to suit your needs.

But primarily, *it's built to work together out of the box to make it as easy as possible to integrate React with Enonic XP*, by handling:

- component compilation/building,
- inserting editorial data into react components,
- isomorphic serverside and clientside rendering and hydration,
- optimizing and serving reusable asset chunks to the client side,
- component reference from anywhere

This guide focuses on the react4xp starter, which handles a full basic setup. But it can also be imported into an existing XP project - the core library docs have https://github.com/enonic/lib-react4xp/blob/master/README.md#installing-the-library[a guide for that].


{nbsp} +
{nbsp} +
{nbsp} +

== Get started

=== Create a starter project

To setup a project locally, run the following command:

  enonic project create -r starter-react4xp

Remember to create a *new XP sandbox* when completing the project wizard.

NOTE: *Don't have the Enonic CLI?* Visit the https://developer.enonic.com/start[Getting started guide] to install it.

{nbsp} +

=== Build and Deploy

To build and deploy the app, run this command from your shell:

  enonic project deploy

Accept starting the sandbox.

[NOTE]
====
To verify that your app started successfully, you should find an entry similar to this in the sandbox log:

  2019-04-09 13:40:40,765 INFO ... Application [<name.of.your.app>] installed successfully
====


{nbsp} +
{nbsp} +
{nbsp} +

== Project structure

If you're used to working with an https://developer.enonic.com/guides/my-first-webapp[ordinary] XP project with https://developer.enonic.com/templates/webpack[webpack], the structure will look familiar - the biggest news is the folder `react4xp/` under `resources/`. Your project folder should now look something like this:

.Selected files:
[source,files]
----
build.gradle <--1-->
settings.gradle <--1-->
package.json <--2-->
build/ <--3-->
src/
  main/
    resources/
      assets/ <!--4-->
      react4xp/ <!--5-->
        _entries <!--6-->
          REPLACE_ME.jsx <!--7-->
      site/
        parts/ <!--8-->
        pages/ <!--8-->
        REPLACE_ME.jsx <!--7-->
      webapp/ <!--9-->
----


<1> The gradle files are used by the build system. The starter includes some setup here: the library *lib-react4xp* and some building tasks that use webpack with configs that are fetched with NPM.
<2> `package.json` sets up NPM package import
<3> `build/` will contain output files produced by the build. All the output from the react4xp build process (along with a few housekeeping data files) will be compiled into the subfolder `build/resources/main/assets/react4xp`. These built assets are used in runtime both on client- and server side.
<4> But note that `assets/react4xp` is NOT the source of those React4xp assets! Just use `assets/` for other, general, non-react4xp static assets such as css and icons, etc.
<5> `react4xp/` is the general folder for react component source files. React4xp will look for `.js` and `.jsx` files here and in all subfolders, and compile them during build. All subfolders below this (except for `_entries` - see below) will be compiled to https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[*chunks*] with the same name as the subfolder. Put nested/reused react components in subfolders like that, and also other code imported by your components.
<6> `react4xp/_entries/` is special and magic. This is the main folder for *https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[entry components]* - react components that can be used directly by React4xp, that is, they don't need to be nested inside other react components.
<7> Two `REPLACE_ME.jsx` files: simply placeholders needed by webpack. Removed each of these when you've added one or more react source file below `react4xp/_entries/` and `site/`.
<8> Below the `site/parts/` and `site/pages/` subfolders is where you put your XP parts and pages, as always. With React4xp, *you can also put `.jsx` entry components together with your parts and pages*. This is link:#_a_shorthand_function_with_same_name_component[the easiest use case]: if they have the same name as the part/page, they are super easy to inject into the part/page from the controller.
<9> Folder containing the root webapp controller. React4xp supplies services that allow even static HTML pages to refer to and request compiled React4xp components.


{nbsp} +
{nbsp} +
{nbsp} +

== Usage

Simply put, there are *4 prototypical usage patterns*. You're not bound to use them exactly like this, and the *link:#_examples[examples]* below will show some more variation than this. But for clarity here's an overview of them:

{nbsp} +

=== A: Shorthand function with same-name component
*The easiest way* is to put one react entry sourcefile into the same folder as a part/page where it should be displayed, and let it have the same file name as the part/page (but `.JSX` extension only!).

Let the React4xp shorthand functions `.renderSafe` (for client-side rendering) or `.render` (for server-side rendering and client-side hydration) use XP's `request` and `portal.getComponent()`. Add some props the same way you would add a model when rendering Thymeleaf, and/or tweak the rendering functions with extra parameters if you want.

The output from these render functions is *a full response object with everything the client needs to display it* - HTML and page contributions. Just return it directly from the controller.

{nbsp} +

=== B: JsxPath references
If you want to *reuse an entry component in multiple parts or pages* (or just, not be bound by the parent part/page folder), put a source file where you want...

  - either a `.JS`/`.JSX`/`.ES6` under `react4xp/_entries`,
  - or a `.JSX` file in any page/part folder under `site/`,

...and use `.render` or `.renderSafe`, but instead of the object from `getComponent`, use the *https://github.com/enonic/lib-react4xp/blob/master/README.md#jsxpath-how-to-refer-to-a-react4xp-component[jsxPath] string*: a name for each entry component, built from the relative path of the JSX file below `react4xp/_entries` or `site/` - without the file extension.

NOTE: JsxPaths are not OS paths that can be used relatively. They are *name strings, and must be used in full*.

TIP: You can see all the built jsxPaths in `build/resources/main/assets/react4xp/entries.json`.

{nbsp} +

=== C: React4xp data objects
If you need *more flexibility*, or want to *use more than one entry component in a single part or page* - or even *use the same react component more than once in a part/page*:

Instead of using the shorthands `.render` or `.renderSafe`, create a temporary data-holding `new React4xp(...)` object in the page/part controller. Use a component or jsxPath argument to point to the react component. When you're done manipulating data, the React4xp object has built-in and specific methods for rendering a body and the necessary page contributions, for client-side or server-side react rendering.

These rendering methods can be *chained*, so that the output HTML or page contribution from one object is the input for the next one. This way, one response object can be built from several react components.

{nbsp} +

=== D: Client-side exposed services
Finally, React4xp can be *used outside of the page/part flow*, even without making XP controllers if needed. A few services are exposed in runtime, where a client can request runnable compiled code:

  - entries, by jsxPath reference,
  - chunks (and lists of chunks), referred by the jsxPath(s) used on a page,
  - a client-side React4xp wrapper, simplifying these manual clientside steps and triggering rendering,
  - React and ReactDOM themselves, the versions used on the serverside. Handy if you're doing SSR and want to be sure it's always the exact same versions doing the rendering everywhere.

This allows you for example to bypass Content Studio if you want, using XP's webapp functionality, making single-page react apps etc.


{nbsp} +
{nbsp} +
{nbsp} +

== Examples

These examples require a little basic experience with Enonic XP 7 (check out the excellent introductions at the https://developer.enonic.com/[Developer Portal]), and a https://developer.enonic.com/guides/my-first-site#page_component[main page component] with a https://developer.enonic.com/guides/my-first-site#regions[region].

The examples build incrementally on each other.

TIP: They can be downloaded along with everything needed to run, by checking out the https://github.com/enonic/starter-react4xp/tree/examples[examples branch of starter-react4xp]

TIP: See the link:#_api[API section] below for more details about how to use what's demonstrated.

{nbsp} +

=== 1: Hello World

Let's make a simple XP part that contains a react component: `01-minimal-example`, which will be rendered entirely at the client side:

.Files involved:
[source,files]
----
site/parts/01-minimal-example/
  01-minimal-example.xml
  01-minimal-example.jsx
  01-minimal-example.es6
----

Nothing in particular is needed in *the part definition*...

.01-minimal-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>01 - Minimal Example</display-name>
  <description>Simple client-side example</description>
  <form />
</part>
----

...and *the react component* itself - the entry - is just _any standard JSX file, as long as it default-exports a function that returns a react element_. The function may optionally take a `props` object parameter - here we'll receive a `greetee` prop and gloriously greet it:

.01-minimal-example.jsx:
[source,jsx,linenums,options="nowrap"]
----
import React from 'react';

export default (props) => <p>Hello {props.greetee}!</p>;
----

*The controller* below imports `React4xp` and uses `.renderSafe` from it, which does a few important things here:

- Uses `request` to determine viewing mode, and choose a suitable rendering. In live mode, `renderSafe` will make a client-side rendering.
- Notes that there is no HTML `body` argument, so the JSX will be the only view to display. So `renderSafe` generates a container `body` HTML element from scratch.
- Uses the XP `component` object (from `portal.getComponent()`) to locate the JSX file in the part folder, with the part name: `01-minimal-example.jsx`. The `component` is also used to create a unique, matching react component ID for the `body` container and the client-side render command that targets it.
- Generates a response object that's directly returned from the controller, to the client. In addition to `body`, some `pageContributions` are generated and added - containing asset download links and JS rendering commands.

.01-minimal-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');

exports.get = function(request) {
    const component = portal.getComponent();
    const props = { greetee: "world" };

    return React4xp.renderSafe(request, { component, props });
};
----

{nbsp} +
{nbsp} +

*That's it. Now let's add this part to a page in Content Studio and render it!*

Run `enonic project deploy` from your shell, start the sandbox and direct your browser to `localhost:8080/admin`. Log in to XP and open Content Studio. If you haven't already, create some content (a site or the included landing page type will do) that uses a page controller with a region. Insert a new part, and select the minimal-example part you just made. Edit it, give it a displayname, save it and enter the preview:

[.thumb]
image::hello-world.png["Glorious greeting of the very existence itself!" width=492px]

If we view the page source code in the browser (and format it and strip away some irrelevant parts), we'll see something like this:
[source,html,options="nowrap"]
----
<!DOCTYPE html>
<html>
  <head>(...)</head>

  <body>

    <main data-portal-region="main" class="xp-region">
      <div (...) id="parts_01-minimal-example__main_0"></div> <!--1-->
    </main>

    <script src="(...) /react4xp/externals.88e80cab5.js"></script>  <!--2-->
    <script src="(...) /react4xp-client/"></script> <!--3-->
    <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--4-->
    <script defer> <!--5-->
      React4xp.CLIENT.render(
        React4xp['site/parts/01-minimal-example/01-minimal-example'],
        "parts_01-minimal-example__main_0",
        { "greetee": "world", "react4xpId": "parts_01-minimal-example__main_0" }
      );
    </script>
   </body>
</html>
----

The important lines here are all added by `.renderSafe` in the part:

<1> The generated target container element (`body`), with an ID. It's empty for now, it won't be filled with "Hello World" before the rendering is triggered.
<2> Downloading React and ReactDOM in an `externals` chunk (the exact path varies with local setups, so it's truncated to `(...)`). When this is run, `React` and `ReactDOM` are globally available in the client.
<3> Downloading the react4xp client wrapper, which enables the rendering command in point #5, among other things. Creates a global client-side object, `React4xp`, which will contain all things React4xp in runtime. The client wrapper is `React4xp.CLIENT`.
<4> Downloading the react component itself - the autocompiled version of `01-minimal-example.jsx`. The runtime-renderable component is put into `React4xp.<jsxPath>`, in this case: `React4xp['site/parts/01-minimal-example/01-minimal-example']`.
<5> A client rendering command `React4xp.CLIENT.render` is generated and triggered, with some arguments: A pointer to the react component, the ID of the element to render the component into, and the props. Note that we only added the `greetee` prop. The other one, `React4xpId`, is the unique ID of the component, same as the element target. It's always added as a react prop for the component. Occasionally handy!

{nbsp} +
{nbsp} +

=== 2: Serverside rendering

In this example we'll create a new part, similar to the link:#_1_hello_world[first] one but with these differences:

- Server-side rendering with hydration: `.render` instead of `.renderSafe`. They have the same parameter signature, but we'll also use it slightly differently here with some manual options:
- A thymeleaf HTML view already exists, and we're rendering the react component into a target container element in it,
- We're not using a 'local' JSX component inside the part. Instead, we're using the `jsxPath` to point elsewhere; to reuse the react entry from the first example.
- We're setting the ID manually, instead of letting `.render` generate it.
- Since we're manually setting both the ID and the jsxPath pointer, we don't need the `component` parameter.
- However, we'll inject some editorial data into the react commponent, using the props. We'll use `getComponents` to fetch those.

.Files involved:
[source,files]
----
site/parts/
  01-minimal-example/
    01-minimal-example.jsx
  02-serverside-example/
    02-serverside-example.xml
    02-serverside-example.html
    02-serverside-example.es6
----

Still an unremarkable *part definition*, but now there's a `greetee` TextLine input field. Here we'll enter something editorial in Content Studio, fetch it in the controller and inject it into the react component.

.02-serverside-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>02 - Server-Side Example</display-name>
  <description>Server-side rendered react component</description>
  <form>
    <input name="greetee" type="TextLine">
      <label>What should be our greeting (after 'Hello')?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>world</default>
    </input>
  </form>
</part>
----

*The view* demonstrates how a target container can be anywhere in an HTML file, and still receive the react injection - same as in vanilla react - as long as we point to it with the ID: `serverside-example-container`.

NOTE: If `.render` or `.renderSafe` are given a `body` to inject react into, but there's no element in the HTML with an `id` that matches the `React4xpId` of the component, a new, empty container with a matching `id` will be added inside the `body`, at the end. In this case it would be injected between line 5 and 6:

.02-serverside-example.html
[source,html,linenums,options="nowrap"]
----
<div class="serverside-example">
    <h2>Server-side rendering example</h2>
    <p>Server-side rendered and hydrated, inserted below:</p>
    <div id="serverside-example-container"></div>
    <p>(SSR example is done).</p>
</div>
----

As usual, the important React4xp stuff happens in *the part controller*:

.02-serverside-example.es6:
[source,javascript,linenums,options="nowrap"]
----
const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

// View file
const view = resolve('02-serverside-example.html');

exports.get = function(request) {
    // Fetching the component data we entered (or, we're about to)
    // in the textfield in Content Studio:
    const component = portal.getComponent();

    // The `.render` shorthand method produces a server-side rendering. <!--1-->
    return React4xp.render(
        request, // `request` is still used to determine viewing mode.
        {
            // Extracting `greetee` from the component data,
            // and setting the value as the `greetee` prop
            props: { greetee: component.config.greetee },

            // Uses jsxPath to use the react entry from the previous
            // example, `01-minimal-example.jsx`. <!--2-->
            jsxPath: 'site/parts/01-minimal-example/01-minimal-example',

            // Manually setting the component's `React4xpId`,
            // identical to the `id` of the rendering target container.
            id: 'serverside-example-container',

            // The `body` parameter is an HTML string.
            // Here, itâ€™s rendered by Thymeleaf based on the view file. <!--3-->
            body: thymeleaf.render(view, {})
        }
    );
};
----

Notes:

<1> In live view, `.render` also *hydrates* the rendered HTML - adds post-filling
       // it with the active react and js functionality on the client:

<2> This *jsxPath structure* is common for all JSX entries below the `site/` folder: `site/<parts-or-pages>/<part-or-page-folder-name>/<filename>`.

<3> *Body and pageContributions parameters:* The `body` and `pageContributions` parameters are *pass-through*! Had this been the `.renderSafe` client-side rendering function, `body` would just have become the `body` in the response output, only with a container element added (possibly. Nothing's added if a matching-`id` element is found in it). But with `.render`, the react component is rendered to HTML by the server using the initial `props`, and inserted into the target container in `body` (which, again, might be a generated target container if the input HTML is missing one). This modified `body` is then returned. On the client, `.render` will `.hydrate` the container, filling in and activating the react component. The `pageContributions` parameter isn't shown here, but works the same way: appending the React4xp output pageContributions to the input ones, if any were given. See the next example.

{nbsp} +
{nbsp} +

*Okay, enough code - let's run the example!*

Add the new part `02-serverside-example` to our page in Content Studio (the way we did in link:#\_1_hello_world[the previous example]). When we edit the part and open the _inspect_ panel on the right, we see the TextField asking us _"What should be our greeting?"_ It suggests _"world"_, but for variation we'll enter _"from the server side"_. This is the `greetee` value, it gets prop'ed into the react component, and we can see the rendered result in the preview on the left:

[.thumb]
image::editing-serverside.png["" width=1037px]

The output page source from the server is very similar to the previous example:
[source,html,options="nowrap"]
----
<body>
  <main data-portal-region="main" class="xp-region">

    <div class="serverside-example">
      <h2>Server-side rendering example</h2>
      <p>Server-side rendered and hydrated, inserted below:</p>
      <div id="serverside-example-container">
        <p data-reactroot="">Hello <!-- -->from the server side<!-- -->!</p> <!--1-->
      </div>
      <p>(SSR example is done).</p>
    </div>

  </main>

  <script src="(...) /react4xp/externals.88e80cab5.js" ></script>
  <script src="(...) /react4xp-client/" ></script>
  <script src="(...) /react4xp/site/parts/01-minimal-example/01-minimal-example.js"></script> <!--2-->
  <script defer> <!--3-->
    React4xp.CLIENT.hydrate(
      React4xp['site/parts/01-minimal-example/01-minimal-example'],
      "serverside-example-container" ,
      {"greetee":"from the server side","react4xpId":"serverside-example-container"}
    );
  </script>
</body>
----

Most noteworthy:

<1> The target container is not initially empty anymore, but contained rendered HTML from the server.
<2> The imported entry is still the same as in the previous example. This is the compiled version of the JSX component we pointed to with `jsxPath` in the controller.
<3> Instead of `.render`, we're triggering `.hydrate`. Here, that doesn't make a difference since our react component doesn't have any more active stuff in it than just outputting an HTML string. But had it had things like event listeners, state, connections to thirdparty libraries etc, `.hydrate` would have hooked those up to the DOM structure created in the target container element, creating a working, active component.

TIP: Server-side rendering can take a long time to produce an output on the first rendering (several seconds). This should happen _very rarely or never_ after the first rendering on the server. What happens is that the component is parsed, compiled and cached on the server. After that, repeated renderings even with different props are very fast!

{nbsp} +
{nbsp} +

=== 3: React4xp objects

Here we won't use the shorthand functions `.render` or `.renderSafe`. Instead, we'll use the explicit syntax that the shorthand functions use under the hood. We'll construct a data-holding React4xp object, and use its built-in methods to specifically and separately render the `body` and the `pageContributions`.

This provides more fine-grained control and opportunities for logic steps during the component creation.

Other new features demonstrated:

- The controller as the source of the target container ID, injecting it both into the view and the react component,
- Referring to a React component outside of XP's `/site/` structure, in the base directory `/react4xp/\_entries`,
- Rendering a `body` with Thymeleaf once, and using it as a static pre-rendered template.
- Making some raw XP pageContributions before rendering, with a script with inserted editorial data. Then passing that `pageContributions` object through the `.renderClientPageContributions`, and getting new pageContributions (which activate the react component as we did before) added to it - retaining the existing pageContributions.

.Files involved:
[source,files]
----
react4xp/_entries/
  ColorThing.jsx
site/parts:
  /03-customflow-example/
    03-customflow-example.xml
    03-customflow-example.html
    03-customflow-example.es6
----

As usual, we start with the *part definition*, and it's still the source of some editorial data: `color`.

.03-customflow-example.xml:
[source,xml,linenums,options="nowrap"]
----
<part>
  <display-name>03 - CustomFlow Example</display-name>
  <description>AKA. The Color Thing</description>
  <form>
    <input name="color" type="TextLine">
      <label>What's the color of the thing?</label>
      <occurrences minimum="1" maximum="1"/>
      <default>red</default>
    </input>
  </form>
</part>
----

Next, let's look at the *react component*. Still not very advanced, but at least it's colorful (sorry):

.ColorThing.jsx:
[source,javascript,linenums,options="nowrap"]
----
import React from 'react';

export default (props) =>
  <div style={{border: `1px dotted ${props.color}`,margin:"5px",padding:"5px" }}>
    <h2>The {props.color} thing</h2>
    <p style={{color: props.color}}>Hey, I'm pretty {props.color}!</p>
  </div>;
----

The thymeleaf *view* has no other purpose than to show that an ID is inserted, turning this into a target container:

.03-customflow-example.html
[source,html,linenums,options="nowrap"]
----
<div data-th-id="${targetId}"></div>
----

Finally, *the controller*:

.03-customflow-example.es6:
[source,javascript,linenums,options="nowrap"]
----

const portal = require('/lib/xp/portal');
const React4xp = require('/lib/enonic/react4xp');
const thymeleaf = require('/lib/thymeleaf');

// Sets the ID for both the react component and the target container...
const TARGET_ID = "color-greeter-id";

const view = resolve('03-customflow-example.html');
const model = {
    targetId: TARGET_ID
};
// ... which is rendered to a static HTML string here and only once:
const PRE_RENDERED_BODY_TEMPLATE = thymeleaf.render(view, model);

exports.get = function(request) {
    const component = portal.getComponent();

    // Constructor for a React4xp object, setting one mandatory parameter:
    // either an XP component object, or as in this case: a jsxPath string. <!--1-->
    const reactComp = new React4xp('ColorThing');

    // Builder pattern for setting the additional optional attributes. <!--2-->
    reactComp
        .setId(TARGET_ID)
        .setProps({
            color: component.config.color
        });

	// Making a normal XP pageContributions object <!--3-->
	const preExistingPageContributions = {
        bodyEnd: `<script>
            console.log('Okay, rendered the ${reactComp.props.color} thing.');
        </script>`
    };

    // Without the shorthand rendering, there are separate rendering
    // functions for body and pageContributions: <!--4-->
    return {
        // `.renderTargetContainer` renders ONLY the target container
        // - no server-side added react content. <!--5-->
        body: reactComp.renderTargetContainer(PRE_RENDERED_BODY_TEMPLATE),

        // `.renderClientPageContributions` only makes
        // client-side rendering script tags. <!--6-->
        pageContributions: reactComp.renderClientPageContributions(
            preExistingPageContributions
        )
    }
};
----

Footnotes from the comments:

<1> Why is `ColorThing`, and only that, the jsxPath to `ColorThing.jsx`? Because it's at the root level of the magic react4xp-entries base folder: `src/main/resources/react4xp/_entries`.

<2> The builder pattern means these optional methods can be chained like in the example or happen separately - in any sequence. The example lines here are equivalent to:

	reactComp.setProps({color: component.config.color});
	reactComp.setId(TARGET_ID);

<3> The `props` are already set in the React4xp `reactComp` object. We can fetch attributes from it before the rendering, in this case reading the `color` prop and injecting it into this mini-script.

<4> So there's no automatic selection of rendering mode. *Try to avoid active client-side JS running in Content Studio's edit mode*. Take care when rendering manually like this. The simplest way is to detect the viewing mode from the `request` object and skip the pageContributions.

<5> `.renderTargetContainer` can be used without an argument. It will then simply generate an empty target container for you, with an `id` matching the react components ID.

<6> We're passing `preExistingPageContributions` _through_ `.renderClientPageContributions`, keeping the script line we made and adding the component's necessary pageContributions to it when it's returned. This method can also be run without an argument, giving you fresh pageContributions.

{nbsp} +

*Okay, let's take a look:*
As before, open Enonic XP, make a new part, select the new part we made: 03-Customflow Example. Edit the part config, and change the color of the thing, for example to "blue". Save, and open the preview.

Unsurprisingly, we should get something like this:

[.thumb]
image::the-blue-thing.png["" width=1068px]

We also see in the console that the little `console.log` script from the controller has picked up the `color` prop _from_ the object, and passed through the `.renderClientPageContributions`, only joined by the generated JS that the client uses to render the blue thing. The rest of the output follows the same logic as we've seen before for a client-side rendering:

[source,html,options="nowrap"]
----
<body>
  <main data-portal-region="main" class="xp-region">
    <div id="color-greeter-id"></div>
  </main>

  <script src="(...) /react4xp/externals.88e80cab5.js"></script>
  <script src="(...) /react4xp-client/"></script>

  <script>console.log('Okay, rendered the blue thing.');</script>

  <script src="(...) /react4xp/ColorThing.js"></script>
  <script defer>
    React4xp.CLIENT.render(
      React4xp['ColorThing'],
      "color-greeter-id",
      { "color": "blue", "react4xpId": "color-greeter-id" }
    );
  </script>
</body>
----

{nbsp} +
{nbsp} +

=== 4: A part with multiple react components, chaining, nesting, hydration

A final example, where we'll look at using multiple react components in a single part - including reusing multiple instances of _the same_ react component and making them unique within the part:

- chaining (passing the body and pageContributions through multiple react4xp data objects),
- nesting shared, non-entry react components in an entry,
- how `import`-ing non-entry code results in a predictable chunk structure,
- `.hydrate` lets the client activate a pre-rendered component.

.Files involved:
[source,files]
----
react4xp/
  myChunk/
    Builder.jsx <!--1-->
  _entries/
    mySubfolder/
      BuilderContainer.jsx <!--2-->
site/parts:
  /04-chaining-example/
    04-chaining-example.jsx <!--3-->
    04-chaining-example.xml <!--4-->
    04-chaining-example.html <!--5-->
    04-chaining-example.es6 <!--6-->
----

<1> InnerGreeter is


{nbsp} +
{nbsp} +

=== 5: Webapp
To see your current application:

. log in to the XP admin console (http://localhost:8080)
. open the "Applications" app, and select the listed applications
. visit the app by clicking the web app link.
==== Services

==== The React4xp client-side object

==== The wrapper: React4xp.CLIENT


== API and details

Link to lib-react4xp

{nbsp} +
{nbsp} +
{nbsp} +

=== API

=== Imports and chunks
When building your react components, *you can import JS/ES6 code as usual*: nested react components, your own secondary code, other frameworks, libraries, whatever... Imported code can be compiled into separate asset chunks from the entries that use them, for https://webpack.js.org/guides/code-splitting/[code splitting].

This chunking is easy to control: *put the imported sources in chunk-named subfolders below the `react4xp/` folder* (outside of `_entries`). Done this way, React4xp will handle:

 - optimized building and serving of the entries and chunks,
 - client-and-server-side caching with cache busting,
 - keep track of exactly which secondary chunks are needed for displaying which component entries,
 - and add the necessary client-side script requests/imports along with the response.

https://github.com/enonic/lib-react4xp/blob/master/README.md#entries-and-dependency-chunks[More about entries and chunks in the core library documentation].

TIP: Chunks are more optimized than entries. Ideally, keep the served entries slim and leave the heavy lifting to chunks.

=== Gotchas

==== Rendering in different modes

=== Adjusting the setup

adjusting pieces of the build
	webpack.configs from NPM packages
	constants: project structure
	externals, mtp SSR
	packages and versions

